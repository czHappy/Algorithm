# 模板 


<!-- TOC -->

- [模板](#模板)
  - [STL](#stl)
  - [数论](#数论)
    - [欧几里得算法](#欧几里得算法)
    - [模线性方程](#模线性方程)
    - [求逆元](#求逆元)
    - [唯一分解定理](#唯一分解定理)
    - [欧拉函数](#欧拉函数)
  - [数学](#数学)
    - [组合数](#组合数)
    - [排列数](#排列数)
    - [错排数](#错排数)
    - [快速幂](#快速幂)
    - [矩阵](#矩阵)
    - [随机数](#随机数)
    - [一些定理](#一些定理)
  - [图论](#图论)
    - [拓扑排序](#拓扑排序)
    - [二分图](#二分图)
      - [二分图判断](#二分图判断)
      - [最大匹配(最小顶点覆盖 最大独立集)](#最大匹配最小顶点覆盖-最大独立集)
    - [最短路](#最短路)
    - [最小生成树](#最小生成树)
    - [LCA](#lca)
    - [强连通分量](#强连通分量)
    - [割点](#割点)
    - [桥](#桥)
    - [差分约束系统](#差分约束系统)
    - [2-sat](#2-sat)
    - [网络流](#网络流)
  - [Tarjan](#tarjan)
    - [Tarjan强连通分量](#tarjan强连通分量)
    - [割点](#割点-1)
    - [桥](#桥-1)
    - [双连通分量](#双连通分量)
  - [树链剖分](#树链剖分)
    - [树上修改查询](#树上修改查询)
    - [树链剖分求LCA](#树链剖分求lca)
  - [树上差分](#树上差分)
    - [点差分](#点差分)
    - [边差分](#边差分)
  - [字符串](#字符串)
    - [KMP](#kmp)
    - [马拉车](#马拉车)
  - [高精度](#高精度)
  - [数据结构](#数据结构)
    - [线段树](#线段树)
    - [单调队列](#单调队列)
  - [筛表](#筛表)
    - [质数普通筛](#质数普通筛)
    - [质数线性筛](#质数线性筛)
    - [质数区间筛](#质数区间筛)
    - [欧拉函数筛](#欧拉函数筛)
  - [DP](#dp)
    - [区间DP](#区间dp)
    - [数位DP](#数位dp)
    - [子序列](#子序列)
    - [概率DP(逆推)](#概率dp逆推)
    - [期望DP(向前转移或者回到自己)](#期望dp向前转移或者回到自己)
  - [组合游戏博弈](#组合游戏博弈)
    - [巴什博奕](#巴什博奕)
    - [威佐夫博弈](#威佐夫博弈)
    - [尼姆博弈](#尼姆博弈)

<!-- /TOC -->

## STL
- list

```c++
#include<list>
pop_back() 删除最后一个元素 
pop_front() 删除第一个元素 
push_back() 在list的末尾添加一个元素 
push_front() 在list的头部添加一个元素
back() 返回最后一个元素 
front() 返回第一个元素 
```
- queue
```c++
#include<queue>
q.size();//返回q里元素个数
q.empty();//返回q是否为空，空则返回1，否则返回0
q.push(k);//在q的末尾插入k
q.pop();//删掉q的第一个元素
q.top();//返回q的第一个元素
q.back();//返回q的末尾元素
priority_queue <T> q;
priority_queue <T,vector<T>,greater<T> > q;
```

- iterator
```c++
T::iterator it;
vector<int> :: iterator it;
	it = t.begin();
	while(it != t.end()){
		cout<<*it<<endl;
		it++; 
    } 
}
```
- operator < 
```c++
//重载小于号
bool operator<(Node a, Node b){//返回true时，说明a的优先级低于b
    //x值较大的Node优先级低（x小的Node排在队前）
    //x相等时，y大的优先级低（y小的Node排在队前）
    if( a.x== b.x ) return a.y> b.y;
    return a.x> b.x; 
}
```

- lower_bound
```c++
The range used is [first,last)

lower_bound(起始地址，结束地址，要查找的数值) 

Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.

upper_bound(起始地址，结束地址，要查找的数值) 

Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.

如果数组中没有找到所求元素，函数就会返回一个假想的插入位置

binary_search(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个bool值。
```

- unique
```c++
//剩下是[0,p) [p,n)是重复的 
int p = unique(a,a+n) - a;
cout<<"pp = "<<p<<endl;
for(int i=0; i<p; i++){
    cout<<a[i]<<endl;
}
```

---
## 数论
### 欧几里得算法
- 模板
```c++
ll gcd(ll a, ll b){
    if(b==0)    return a;
    else return gcd(b,a%b);
}
//在求a，b的gcd的同时求出一组特解 x,y满足方程  ax + by = gcd(a,b)
void extgcd(ll a,ll b,ll& d,ll& x,ll& y){
    if(!b){ d=a; x=1; y=0;}
    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }
}

```
- 关于方程 ax + by = c  
  - 若gcd(a,b) | c,则方程有解，否则无解。
  - 否则齐次通解(x0 y0是特解)  
    x = x0 + b/gcd(a,b) * t  
    y = y0 - a/gcd(a,b) * t
  - 对应方程 ax + by = c只需要在通解基础上乘以一个比例系数：c/gcd(a,b)
- 最小正整数解
  - 使用拓展欧几里德找到ax+by=c的一组整数解(x0,y0)之后，令k=b/gcd(a,b)，x'=(x0%k+k)%k，y'=(c-ax)/b，就可以得到x的最小正整数解。
  - 同理，令k=a/gcd(a,b)，y'=(y0%k+k)%k，x'=(c-by)/a，就可以得到y的最小正整数解。

### 模线性方程
- 解模线性方程 ax ≡ b (mod p)
```c++
ll linearCong(ll a, ll b, ll p){
    ll d,x,y;
    extgcd(a,p,d,x,y);
    if(b % d != 0)    return -1;
    x = x*b/d;
    x = (x%p + p) % p;
    return x;
}
```
- 中国剩余定理 


    ![](CRT.png) 

```c++
int CRT(int a[],int m[],int n)
{
    int M = 1;
    int ans = 0;
    for(int i=1; i<=n; i++)
        M *= m[i];
    for(int i=1; i<=n; i++)
    {
        int x, y;
        int Mi = M / m[i];
        extend_Euclid(Mi, m[i], x, y);
        ans = (ans + Mi * x * a[i]) % M;
    }
    if(ans < 0) ans += M;
    return ans;
}

```

### 求逆元
```c++
#include<iostream>
using namespace std;
typedef  long long ll;

//扩展欧几里得求逆元
void extgcd(ll a,ll b,ll& d,ll& x,ll& y){
    if(!b){ d=a; x=1; y=0;}
    else{ extgcd(b,a%b,d,y,x); y-=x*(a/b); }
}
ll inverse(ll a,ll n){
    ll d,x,y;
    extgcd(a,n,d,x,y);
    return d==1?(x+n)%n:-1;
}

ll gcd(ll a, ll b){
    if(b == 0)    return a;
    return gcd(b , a%b);
}

ll qPow(ll a ,ll n,ll mod){
    ll ans = 1;
    //如果n的二进制最后一位是1 结果参与运算 
    //因为如果是0，那么幂运算之后该项是1,1乘任何数还是那个数，对结果不影响
    while(n > 0){
        if(n & 1)  
            ans = (ans* a) % mod;
        a = (a*a) % mod;//底数加倍 
        n >>= 1;//移位 
    }
    return ans;    
}


/*
费马小定理求逆元，p是质数，且gcd(a,p)=1
在模为素数p的情况下，有费马小定理 
ap-1 ≡ 1（mod p） 
则a * ap-2 ≡ 1（mod p）费马小定理求逆元，p是质数，且gcd(a,p)=1
在模为素数p的情况下，有费马小定理 
ap-1 ≡ 1（mod p） 
则a * ap-2 ≡ 1（mod p）
*/
ll invEle(ll a, ll mod){
     
    //如果a 和 模数不互质则必然不存在逆元 
    if(gcd(a,mod) != 1 || mod < 2)    return -1;
    return qPow(a,mod-2,mod);
}

int main(){
    ll a,b;
    int x,y;
    while(cin>>a>>b){
        cout<<invEle(a,b)<<endl;
    }
}

```
### 唯一分解定理
![](分解.PNG)


### 欧拉函数
- 对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）
-  φ(x)=x(1-1/p(1))(1-1/p(2))(1-1/p(3))(1-1/p(4))…..(1-1/p(n)) 其中p(1),p(2)…p(n)为x的所有质因数;
- 模板
```c++
int Euler(int n){
    int ans = n;
    //这里的n在不断收缩  循环次数上界将越来越小 
    for(int i=2; i<=n; i++){
        if(n % i == 0){
            ans = ans - ans/i; 
        }
        //把该素因子除尽 
        while(n % i == 0)    n = n/i;
    }
    return ans;
}
```

## 数学
### 组合数
```c++ 
//直接求 
ll C(ll n, ll r)//组合数
{    ll sum = 1;
     for (int i = 1; i <= r; i++)
      sum = sum * (n+1-i)/i;
   return sum;
}
//打表
ll comb[200][100];//comb[n][m]就是C(n,m)
void init(){
    for(int i=1; i<N; i++){
        comb[i][0] = comb[i][i] = 1;
    }
    for(int i = 1; i < N; i ++){
        for(int j = 1; j < i; j++){
            comb[i][j] = (comb[i-1][j] + comb[i-1][j-1] );
        }
    }
}
```
### 排列数
```c++
ll A(int n, int m){
	ll ans = 1;
	for(int i=n; i>=n-m+1; i--){
		ans = ans * i % mod;
	}
	return ans;
}

```
### 错排数
- dp[0] = 1, dp[1] = 0, dp[2] = 1
- dp[i] = (i-1)*(dp[i-2] + dp[i-1]);

### 快速幂
```c++
// ans = a^n % mod 
ll qPow(ll a ,ll n,ll mod){
    ll ans = 1;
    //如果n的二进制最后一位是1 结果参与运算 
    //因为如果是0，那么幂运算之后该项是1,1乘任何数还是那个数，对结果不影响
    while(n > 0){
        if(n & 1)  
            ans = (ans* a) % mod;
        a = (a*a) % mod;//底数加倍 
        n >>= 1;//移位 
    }
    return ans;    
}
```
### 矩阵
- 矩阵快速幂
- 矩阵状态转移
```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#define maxn 
using namespace std;
typedef long long ll;
int n = 4;
//定义矩阵
struct Matrix {
    ll ma[5][5];
};

int L,M;
//矩阵乘法
Matrix multi(Matrix a, Matrix b) {
    Matrix ans;
    memset(ans.ma, 0, sizeof(ans.ma));
    ll i, j, k;
    for(i=1; i<=n; ++i)
        for(j=1; j<=n; ++j)
            for(k=1; k<=n; ++k)
                ans.ma[i][j] = (ans.ma[i][j] + a.ma[i][k]*b.ma[k][j]%M) % M;
    return ans;
}
//矩阵快速幂取模
Matrix pow(Matrix a, ll x) {
    Matrix ans;
    memset(ans.ma, 0, sizeof(ans.ma));
    ll i, j;
    
    for(i=1; i<=n; ++i)
        ans.ma[i][i] = 1;
        
    while(x) {
        if(x & 1)
            ans = multi(ans, a);
        a = multi(a, a);                         
        x >>= 1;
    }
    return ans;
}
 
int main()
{
    
    Matrix ans;
    while(cin>>L>>M) {
        if(L == 0){
            cout<<0<<endl;
            continue;
        }
        if(L == 1){
            cout<<2%M<<endl;
            continue;
        }
        if(L == 2){
            cout<<4%M<<endl;
            continue;
        }
        //初始化转移矩阵
        memset(ans.ma , 0, sizeof ans.ma);
        ans.ma[1][2] = 1;
        ans.ma[2][4] = 1;
        ans.ma[3][1] = 1;
        ans.ma[3][2] = 1;
        ans.ma[4][3] = 1;
        ans.ma[4][4] = 1;

        //转移K次之后得到结果矩阵
        ans = pow(ans, L-2);
        
        ll sum = 0;
        for(int i=1; i<=n; i++){
            for(int j=1; j<=n; j++){
                //cout<< ans.ma[i][j]<<" ";
                sum += ans.ma[i][j];
                sum %= M;
                
            }
        }
        
        cout<<sum<<endl;
        
    }
    
    return 0;
}
```

### 随机数
```c++
#include <iostream>
#include <stdlib.h>
#include <time.h> 
using namespace std; 
int main()
{ 
    //注意rand()范围是0-32767 0-0x7fff
	int a = 100,b=400;
    //系统时钟作为种子
	srand((unsigned)time(NULL)); 
	for(int i = 0; i < 10; i++ ) {
	    cout << rand() << '\t';
	}
	cout<<endl;
	for(int i = 0; i < 10; i++ ) {
		cout << rand() % (b-a+1) + a << '\t'; 
	}   
	cout << endl; 
	return 0;
}

//要取得[a,b)的随机整数，使用(rand() % (b-a))+ a; 
//要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a; 
//要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1; 
//通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。 
//要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。 
//要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。

```

### 一些定理
- Zeckendorf定理：齐肯多夫定理任何正整数可以表示为若干个不连续的Fibonacci数之和。
- Dliworth定理
  - 最长不上升子序列的个数等于最长上升子序列的长度
  - 最长不下降子序列的个数等于最长下降子序列的长度
  - 一个序列的上升序列的最少个数等于最长不上升子序列的长度。
  - 一个序列的下降序列的最少个数等于最长不下降子序列的长度。
  - 


## 图论
### 拓扑排序
- dfs
```c++
vector<int> G[maxn];
vector<int> order;
int n,m;
bool vis[maxn];

void dfs(int v){
    vis[v] = 1;
    for(int i=0; i<G[v].size(); i++){
        int w = G[v][i];
        if(!vis[w]){
            dfs(w);
        }
    }
    order.push_back(v);
}

void solve(){
    rep(i,1,n){
        if(!vis[i]){
            dfs(i);
        }
    }
}

int main(){
    while(sc(n)!=EOF){
        rep(i,1,n){
            G[i].clear();
            vis[i] = 0;
        }
        order.clear();
        sc(m);
        if(m==0 && n==0) break;
        int u,v;
        rep(i,1,m){
            sc2(u,v);
            G[u].push_back(v);
        }
        solve();
        for(int i=n-1; i>=0; i--){
            printf("%d ", order[i]);
        }
        printf("\n");
    }
    return 0;
}
```
- 度

### 二分图

#### 二分图判断
```c++
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
const int maxn = 10010;
int n,m;//顶点数 边数 
vector<int> G[maxn];
int color[maxn] ;
//0 没染色      1 -1不同色 
bool dfs(int u, int c){
    color[u] = c;
    for(int i=0; i<G[u].size(); i++){
        int v = G[u][i];
        if(color[v] == c)    return false;
        if(color[v] == 0 && !dfs(v,-c))    return false;
    }
    return true;
}

bool solve(){
    for(int i=1; i<=n; i++){
        if(color[i] == 0)
            if(!dfs(i,1)){
                return false;
            } 
    }
    return true;
}

int main(){
    int t;
    cin>>t;
    while(t--){
        cin >> n >> m;
        memset(color, 0, sizeof(color));
        for(int i=0; i<maxn; i++)    G[i].clear();
        for(int i = 0; i < m;  i++)
        {
            int s, t;
            cin >> s >> t;
            G[s].push_back(t);
            G[t].push_back(s);  // 如果有向图则无需这一句
        }
        
        if(solve()){
            cout<<"Correct"<<endl;
        }
        else    cout<<"Wrong"<<endl;
    }
    
    return 0;

}

```
#### 最大匹配(最小顶点覆盖 最大独立集)
- 二分图最小顶点覆盖
  - 定义：假如选了一个点就相当于覆盖了以它为端点的所有边。最小顶点覆盖就是选择最少的点来覆盖所有的边。

  - 定理：最小顶点覆盖等于二分图的最大匹配。

- 最大独立集
  - 定义：选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。找出一个包含顶点数最多的独立集称为最大独立集。

  - 定理：最大独立集 = 所有顶点数 - 最小顶点覆盖 = 所有顶点数 -   最大匹配

```c++
//最大匹配
int match[maxn];
vector<int> G[maxn];
bool vis[maxn];
int n, m;

bool dfs(int u)
{
    for(int i=0; i<G[u].size(); i++){
        int v = G[u][i];
        if(!vis[v]){
            vis[v] = 1;
            if(match[v] == -1 || dfs(match[v])){
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

void solve(){
    int ans = 0;
    MS(match, -1);
    for(int i = 1; i <= m; i++){
        MS(vis, 0);
        if(dfs(i)) ans++;
    }
    printf("%d\n", ans);
}

int main()
{
    int k;
    while(sc(k) != EOF){
        if(k == 0) break;
        sc2(m,n);
        MS(G, 0);
        for(int i = 1; i <= k; i++) {
            int u, v;
            sc2(u,v);
            //G[u][v] = 1;
            G[u].push_back(v);
        }
        solve();
    }
    return 0;
}

```


### 最短路
- 迪杰斯特拉
```c++
int n,m;//顶点数 边数
struct node{
    int dis;//与源点的当前最小距离
    int v;//顶点
    node(){}
    node(int vv, int d){v = vv; dis = d;}
};

bool operator < (node a, node b){
    if(a.dis == b.dis) return a.v > b.v;
    return a.dis > b.dis;
}
//链式前向星基本操作  也可以改成vector数组
int head[maxn];
int cnt;
struct star{
    int to;
    int w;
    int nxt;
}edge[2*M];

void addEdge(int u, int v, int w){
    edge[cnt].to = v;
    edge[cnt].w = w;
    edge[cnt].nxt = head[u];
    head[u] = cnt++;
}

//记录各个顶点到源点的最短距离
ll dist[maxn];
bool vis[maxn]; //记录被选入S集合的顶点 
//堆优化的迪杰斯特拉算法
void dijkstra(int s){
    //建立优先队列，优先关键字是到源点的距离
    priority_queue<node> q;
    rep(i , 1, n) dist[i] = inf,vis[i] = 0;
    dist[s] = 0;
    //初始结点入队
    q.push(node(s, 0));

    while(!q.empty()){
        //取出队首 结点 这个点就是最短路径点
        node fr = q.top();
        q.pop();
        
        int v = fr.v;//顶点
        int dis = fr.dis;//该结点到源点的最短距离
        vis[v] = 1;//该顶点被选入S集合 
        //对v所能到达的顶点做松弛操作
        for(int i=head[v]; i; i=edge[i].nxt){
            int to = edge[i].to;
            if(!vis[to] && dist[to] > dis + edge[i].w){
                dist[to] = dist[v] + edge[i].w;
                q.push(node(to ,  dist[to]));
            }
        }
        
    }
}

int s,e;
int main(){
    ios::sync_with_stdio(false);
    while(cin>>n>>m){
        cin>>s>>e;
        cnt = 1;
        MS(head , 0);
        int u,v,w;
        rep(i,1,m){
            cin>>u>>v>>w;
            addEdge(u , v , w);
            addEdge(v , u , w);
        }
        dijkstra(s);
        cout<<dist[e]<<endl;
    }
    return 0;
}
```

- SPFA
```c++
const int M = 1e4+10;

int n,m;//顶点数边数
int head[maxn];//记录顶点的第一条边
int cnt; //记录当前是第几条边
//边
struct node{
    int to;
    int w;
    int nxt;
}edge[2*M]; //无向图的话要开两倍
//加边
void addEdge(int u, int v, int w){
    edge[cnt].to = v;
    edge[cnt].w = w;
    edge[cnt].nxt = head[u];
    head[u] = cnt++;
}

bool vis[maxn];//记录是否在队列
int dis[maxn];//记录当前最短距离
int in[maxn];//记录结点被入队了多少次，如果大于n则说明有负环
//int path[maxn];//记录前驱
bool SPFA(int s){
    //初始化
    rep(i,1,n){
        vis[i] = 0;
        dis[i] = inf;
        in[i] = 0;
    }
    queue<int> q;
    q.push(s);
    vis[s] = 1;
    dis[s] = 0;//到自己的距离为0
    in[s] = 1;
    while(!q.empty()){
        int fr = q.front();
        q.pop();
        vis[fr] = 0;//出队后置为0
        //对每个与fr相连的顶点 对其进行松弛操作
        for(int i=head[fr]; i!=0; i=edge[i].nxt){
            int v = edge[i].to;
            int w = edge[i].w;
            if(dis[v] > dis[fr] + w){
                //pre[v] = fr;
                dis[v] = dis[fr] +  w;
                if(!vis[v]){
                    q.push(v);
                    in[v]++;
                    vis[v] = 1;
                    if(in[v] > n) return false;
                }
            }
        }
    }
    return true;
}

int main(){
    while(cin>>n>>m){
        if(n==0 && m == 0) break;
        int u,v,w;
        cnt = 1;//第一条边
        MS(head , 0 );
        rep(i , 1, m){
            cin>>u>>v>>w;
            addEdge(u , v , w);
            addEdge(v , u , w);

        }
        int s;
        s = 1;
        if(SPFA(s)) cout<<dis[n]<<endl;
        else cout<<"-1"<<endl;
    }
    return 0;
}
```

- Floyd
```c++
int dis[maxn][maxn];
int s,e;
int x,y,w;
int n,m;

//起点可以从0 改为 1
void Floyd(){
    rep(k,0,n)//中继点从0到n开始枚举
    rep(i,0,n)// 从i到j的距离更新 可以多经过中继点
    rep(j,0,n)
    if(dis[i][j] > dis[i][k] + dis[k][j]) 
    dis[i][j] = dis[i][k] + dis[k][j];
}

int main(){
    while(cin>>n>>m){
        rep(i,0,n){
            rep(j,0,n){
                if(i==j) dis[i][j] = 0;
                else dis[i][j] = inf;
            }
            
        }
        rep(i,1,m){
            cin>>x>>y>>w;
            if(dis[x][y] > w){
                dis[x][y] = w;
                dis[y][x] = w;
            }
            
        }

        Floyd();

        cin>>s>>e;
        if(dis[s][e] == inf) cout<<-1<<endl;
            else cout<<dis[s][e]<<endl;
        }
    return 0;
}
```
### 最小生成树
- 普利姆算法
```c++
 int dis[maxn];//记录每个顶点到S集合的所有边的长度
    int vis[maxn];//点是否在S集合
    int G[maxn][maxn];//存图
    int x,y,w;
    int sum;
    int n,m;
    void Prim(int s){
        MS(vis ,  0);
        vis[s] = 1;
        //s进入S集合，初始化一下dis
        rep(i,1,n){
            dis[i] = G[i][s];
        }
        //还需要选n-1个点
        rep(i , 1 ,  n-1){
            int minx=inf;
            int index;
            //从dis中找出一个最小的
            rep(j,1,n){
                if(!vis[j] && dis[j] < minx){
                    minx = dis[j];
                    index = j;
                }
            }
            //这个顶点被加入S集合 因为这个顶点到S集合的边最小
            vis[index] = 1;
            sum += minx;//最小生成树总长加上该边的值
            //由于这个顶点的加入，使得余下V-S顶点到S集合的距离发生了变化
            rep(j , 1, n){
                if(!vis[j] && G[index][j] < dis[j]){
                    dis[j] = G[index][j];
                }
            }
        }
    }
    int main(){
        //while(cin>>n>>m){
        while(cin>>n){
            if(n == 0) break;
            rep(i,1,n)
            rep(j,1,n)
            if(i==j) G[i][j] =  0;
            else G[i][j] = inf;
            sum = 0;
            rep(i,1,n*(n-1)/2){
                cin>>x>>y>>w;
                G[x][y] = w;
                G[y][x] = w;
            }

            Prim(1);
            cout<<sum<<endl;

        }
        return 0;
    }

```


- 克鲁斯卡尔算法

```c++
int n;//边数
    int m;//顶点数
    int fa[maxn];//根节点
    //把边按照从小到大排序
    struct node{
        int u,v,w; 
    }edge[M];

    bool cmp(node a, node b){
        return a.w < b.w;
    }

    //并查集基本操作
    void init(){
        rep(i,1,n){
            fa[i] = i;
        }
    }
    int find(int x){
        if(x != fa[x]){
            return fa[x] = find(fa[x]);
        }
        return fa[x];
    }
    void merge(int x, int y){
        int fx = find(x);
        int fy = find(y);
        if(fx != fy){
            fa[fx] = fa[fy];
        }
    }

    int main(){
        int x,y,w;
        ios::sync_with_stdio(false);
        while(cin>>n){
            if(n  == 0) break;
            m = (n-1)*n/2;
            int sum = 0;
            init();
            rep(i , 1, m){
                cin>>x>>y>>w;
                edge[i].u = x;
                edge[i].v = y;
                edge[i].w = w;
            }
            sort(edge+1,  edge+1+m,cmp);//把边从小到大
            //从小到大筛边 遇到 环则跳过
            rep(i,1,m){
                node cur = edge[i];
                int u = cur.u;
                int v = cur.v;
                int w = cur.w;
            //如果u,v处于同一个集合，在加入uv边则必形成环
                if(find(u) != find(v)){
                    sum += w;
                    merge(u,v);
                }
            }
            cout<<sum<<endl;
        }
        return 0;
    }
```

### LCA
- Tarjan
```c++
int n,q;//n个顶点 q次询问
int lca[maxn];//lca[i]表示第i个询问的结果 祖先
int dist[maxn];//dist[i]表示i到根节点的距离

//对树建图
int head[maxn];
int cnt;
struct node{
    int v,nxt,w;
}edge[maxn*2];

//对询问建图
int headq[maxn];
int cntq;
struct Node{
    int u,v;//起点和终点
    int nxt;//同起点的下一个询问的位置
    int id;//记下是第几次询问
}query[M*2];

bool vis[maxn];//访问标志
//树加边
void addEdge(int u, int v, int w){
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].nxt = head[u];
    head[u] = cnt++;
}
//询问加边
void addQ(int u, int v, int idx){
    query[cntq].u = u;
    query[cntq].v = v;
    query[cntq].nxt = headq[u];
    query[cntq].id = idx;
    headq[u] = cntq++;
}
//并查集基本操作
int fa[maxn];
void init(){
    rep(i,1,n+5){
        fa[i] = i;
        vis[i] = 0;
        head[i] = 0;
        headq[i] = 0;
    } 
    dist[1] = 0;
    cnt = 1;
    cntq = 1;
}

int find(int x){
    if(x != fa[x]){
        return fa[x] = find(fa[x]);
    }
    return x;
}
void merge(int x, int y){
    int fx = find(x);
    int fy = find(y);
    if(fx != fy) fa[fy] = fx;
}

//tarjan
void tarjan(int u){
    vis[u] = 1;
    for(int i=head[u]; i; i=edge[i].nxt){
        int v = edge[i].v;
        int w = edge[i].w;
        if(!vis[v]){
            dist[v] = w + dist[u];//沿途求出每个结点到root的距离 root=1
            tarjan(v);
            merge(u , v);//v回溯，u是v的父亲
        }
    }
    //u结束 u回溯，把与u有查询关系的能更新的都更新了
    for(int i=headq[u]; i; i=query[i].nxt){
        int v = query[i].v;
        if(vis[v]) lca[query[i].id] = find(v);
    }
}

int t;
int main(){
    sc(t);
    while(t--){
        
        sc2(n,q);
        init();//初始化不能忘记
        int u,v,w;
        rep(i,1,n-1){
            sc2(u,v);
            sc(w);
            addEdge(u,v,w);
            addEdge(v,u,w);
        }
        rep(i,1,q){
            sc2(u,v);
            addQ(u,v,i);
            addQ(v,u,i);
        }
        tarjan(1);
        //事实上可以只选出奇数或者偶数次序的询问因为 （1,2） （3,4） （5,6）...括号内是等价的
        rep(i,1,cntq-1){
            i++;
            u = query[i].u;
            v = query[i].v;
            int idx = query[i].id;
            pfd(dist[u]+dist[v]-2*dist[lca[idx]]);
            
        }
    }


    return 0;
}
```

- 倍增
```c++
int t,n;
vector<int> G[maxn];
int in[maxn];//记录入度
int s,e,lca;
int depth[maxn];//记录每个结点的深度 根节点深度为0
int fa[maxn][20];//fa[i][j]表示i结点向上爬 2^j是哪个结点

//预处理出每个结点的深度和其直接父节点
void dfs(int u, int pre, int d){
    fa[u][0] = pre;//向上一个当然是直接父节点 pre
    depth[u] = d;//深度
    for(int i=0; i<G[u].size(); i++){
        int v = G[u][i];
        if(v != pre){
            dfs(v , u, d+1);
        }
    }
}
//倍增预处理出fa数组
void init(){
    //有点区间DP的意思
    for(int j=0; (1<<(j+1))<n; j++){
        for(int i=1; i<=n; i++){
            if(fa[i][j] < 0) fa[i][j+1] = -1;
            else fa[i][j+1] = fa[fa[i][j]][j];
        }
    }
}
//给定俩个结点在线求其LCA
int LCA(int u, int v){
    //保证v是较深的点
    if(depth[u] > depth[v]) swap(u , v);
    int temp = depth[v] - depth[u];//深度差
    //先把v调到与u等高处
    for(int i=0; (1<<i)<=temp; i++){
        if((1<<i) & temp) v = fa[v][i];
    }
    if(u==v) return u;
    //然后两个人比翼双飞
    for(int i=(int)(log(1.0*n)/log(2.0)); i >= 0; i--){
        if(fa[u][i] != fa[v][i]){
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];

}
int main(){
    sc(t);
    int u,v;
    while(t--){
        sc(n);
        rep(i , 1, n){
            G[i].clear();
            in[i] = 0;
        }
        rep(i , 1, n-1){
            sc2(u,v);
            G[u].push_back(v);
            G[v].push_back(u);
            in[v]++;
        }
        sc2(s,e);
        int root;
        rep(i , 1, n) if(in[i] == 0) root = i; //找到树根节点
        dfs(root, -1, 0);
        init();
        pfd(LCA(s,e));
        
    }
    return 0;
}
```

- RMQ
```c++
int n;
vector<int> G[maxn];//存树
int s,e;
int depth[2*maxn];///存结点深度
int order[2*maxn];//存储树的dfs序列
int dp[2*maxn][20];//存以i为起点的长度为2^j的区间最大值在dfs序列所处的位置
int first[maxn];//存储结点i第一次被访问到时在dfs序列中的位置
int cnt;//记数  dfs序列
bool vis[maxn];//访问标记
int in[maxn];
void init(){
    rep(i,1,n){
        G[i].clear();
        vis[i] = 0;
        in[i] = 0;
    }
    cnt = 0;
}
void dfs(int u, int d){
    vis[u] = 1;
    order[++cnt] = u;
    depth[cnt] = d;
    first[u] = cnt;
    for(int i=0; i<G[u].size(); i++){
        int v = G[u][i];
        if(!vis[v]){
            dfs(v,d+1);
            order[++cnt] = u;
            depth[cnt] = d;
        }
    }
}

void ST(int n){
    for(int i=1; i<=n; i++) dp[i][0] = i;
    int k = (int)(log2(n*1.0));
    for(int j=1; j<=k; j++)
    for(int i=1; i+(1<<j)-1<=n; i++){
        int a = dp[i][j-1];
        int b = dp[i+(1<<(j-1))][j-1];
        if(depth[a] < depth[b]) dp[i][j] = a;
        else dp[i][j] = b;
    }
}

int RMQ(int l , int r){
    int k = (int)(log2(1.0*r - l + 1));
    int a = dp[l][k];
    int b = dp[r - (1<<k) + 1][k];
    if(depth[a] < depth[b]) return a;
    else return b;

}

int LCA(int x, int y){
    //先找出x ,y第一次出现的位置
    int l = first[x];
    int r = first[y];
    if(l > r) swap(l , r);//注意左边小于右边
    //在[l,r]内寻找深度最大的位置
    int pos = RMQ(l , r);
    return order[pos];
}
int t;
int main(){
    sc(t);
    int u,v;
    while(t--){
        sc(n);
        init();
        rep(i , 1, n-1){
            sc2(u,v);
            G[u].push_back(v);
            //G[v].push_back(u);
            in[v]++;
        }
        sc2(s,e);
        int root;
        rep(i , 1, n) if(in[i] == 0) root = i; //找到树根节点
        dfs(root , 1);
        ST(2*n-1);
        pfd(LCA(s,e));
        
    }
    return 0;
}
```

### 强连通分量 
- Tarjan
```c++
int n,m;//顶点数 边数 
vector<int> G[maxn];//存图 
int sccCount;//强连通分量的个数 
int id;//记录访问次序 
bool onStack[maxn];//记录该点是否在栈上 
int ids[maxn];//记录该顶点是哪一次被访问到的 
int low[maxn];//low值 
stack<int> stak;//栈 
int color[maxn];//color[i]表示i被涂成的颜色
int sz[maxn];//sz[i]表示强连通分量i的大小 
//从一点出发dfs 如果dfs调用完毕后，该结点的id值等于low值 说明得到一个scc 
void dfs(int u){
    stak.push(u);//入栈 
    onStack[u] = 1;//标记 
    ids[u] = low[u] = id++;//记录访问次序 和  low值 
    for(int i=0; i<G[u].size(); i++){ //遍历所有邻接点 
        int v = G[u][i];
        if(!ids[v]) dfs(v);//如果没有访问过则继续dfs 
        if(onStack[v]) low[u] = min(low[u] , low[v]);//如果访问过了，并且在栈上
        //则回溯更新  栈的作用实际上是使各个SCC互不干涉 
    }
    //如果这个顶点是最早入栈的那个  则SCC已经形成 
    //认为他能代表这个SCC缩成的点 
    if(ids[u] == low[u]){
        sccCount++;//下一个SCC 
        while(true){
            int tp = stak.top();
            stak.pop();
            color[tp] = sccCount; 
            sz[sccCount]++;//size增加 
            onStack[tp] = 0;//栈标记取消 
            low[tp] = ids[u];//low值同一更新成u的 不要也行 
            if(tp == u) break;//到u了不要再弹了 
        }
    }
}

void tarjan(){
    id = 0;
    sccCount=0;
    MS(ids , 0);
    MS(sz , 0);
    rep(i , 1, n){
        if(!ids[i]) dfs(i);
    }
    int idx;
    int maxx = -1;
    rep(i,1,n){
        if(sz[i] > maxx){
            idx = i;
            maxx = sz[i];
        }
    }
    cout<<sz[idx]<<endl;
    
    rep(i,1,n){
        if(color[i] == idx){
            cout<<i<<" ";
        }
    }
    cout<<endl;

}

int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    int u,v,w;
    rep(i,1,m){
        cin>>u>>v>>w;
        G[u].push_back(v);
        if(w == 2) 
            G[v].push_back(u);
    }
    tarjan();
    return 0;
}
```
- Kosaraju算法

```c++
int n,m;
vector<int> G[maxn];//原图
vector<int> reG[maxn];//逆向图
bool vis[maxn];//访问标记
stack<int> order;//逆向图的逆序访问顺序

int col[maxn];//顶点染色
int cnt;//强连通分量的个数
int sz[maxn];///每个强连通分量的大小
//初始化
void init(){
    rep(i,1,n){
        G[i].clear();
        reG[i].clear();
        vis[i] = 0;
        col[i] = 0;  
        sz[i] = 0;
    } 
    while(!order.empty()) order.pop();
    cnt = 0;
}

//复用DFS   R表示是不是遍历逆向图 如果是 则 不需要染色并且需要入栈 否则需要染色 不需要入栈
void dfs(vector<int> G[] , int s, bool  R){
    vis[s] = 1;
    if(!R){
        col[s] = cnt;//把这个顶点染色成cnt
        sz[cnt]++;//该颜色连通 分量size++
    }
    for(int i=0; i< G[s].size(); i++){
        int v = G[s][i];
        if(!vis[v]) dfs(G,v,R);
    }
    if(R) order.push(s);//逆序进栈
} 
//获取反向图的逆序遍历序列
void getOrder(){
    rep(i,1,n){
        if(!vis[i]) dfs(reG , i, 1);
    }
    
}
//求强连通分量 按照order序列顺序dfs原图
void getSCC(){
    MS(vis , 0);
    while(!order.empty()){
        int u = order.top();
        order.pop();
        if(!vis[u]){
            cnt++;//产生一个以U为主导的新的强连通分量 
            dfs(G , u , 0);
        }
    }
}
//打印结果
void solve(){
    int mx = -1, color = 1;
    rep(i , 1, n){
        if(sz[i] > mx){
            mx = sz[i];
            color = i;
        }
    }
    cout<<mx<<endl;
    rep(i , 1, n){
        if(col[i] == color){
            cout<<i<<" ";
        }
    }
    cout<<endl;
}
int main(){ 
    int u,v,x;
    while(cin>>n>>m){
        init();
        rep(i,1,m){
            cin>>u>>v>>x;
            G[u].push_back(v);
            reG[v].push_back(u);
            if(x==2){
                G[v].push_back(u);
                reG[u].push_back(v);
            }
        }
        getOrder();
        getSCC();
        solve();
    }
    return 0;
}
```

### 割点
- 定义
- Tarjan
```c++
const int maxn = 1e6+10;
int dx[4] = {0, 0, 1, -1};
int dy[4]  = {1, -1, 0 , 0};
int n,m;
int low[maxn];
int ids[maxn];
bool vis[maxn];
int id;
vector<int> G[maxn];
int out;//记录根节点的出边个数
bool isArt[maxn];

void dfs(int root, int u, int pre){
    if(pre == root) out++;
    vis[u] = 1;
    low[u] = ids[u] = ++id;
    for(int i=0; i<G[u].size(); i++){
        int v = G[u][i];
        if(v == pre) continue;
        if(!vis[v]){
            dfs(root , v, u);
            low[u] = min(low[u] , low[v]);
            if(ids[u] <= low[v]){
                isArt[u] = true;
            }
        }
        else{
            low[u] = min(low[u] , ids[v]);
        }
    }
}

void findArticulation(){
    id = 0;
    MS(vis , 0);
    MS(isArt, 0);
    rep(i,1,n){
        if(!vis[i]){
            out = 0;
            dfs(i,i,-1);
            isArt[i] = (out > 1);
        }
    }
}

int main(){
    while(sc2(n,m)!=EOF){
        //if(n == 0) break;
        rep(i,1,n)  G[i].clear();
        int u,v;
        rep(i,1,m){
            sc2(u,v);
            G[u].push_back(v);
            G[v].push_back(u);
        }
        findArticulation();
        int cnt = 0;
        rep(i,1,n){
            if(isArt[i]) cnt++;
        }
        pfd(cnt);
    }
    return 0;
}
```
### 桥
- 定义
- Tarjan
```c++
int n,m;
int low[maxn];//顶点的low值
int ids[maxn];//顶点的dfs次序
bool vis[maxn];//访问标记
int id;//dfs次序
vector<int> G[maxn];//存图

struct edge{
    int u,v;
    edge(int a, int b){u = a; v = b;}
    bool operator < (const edge x) const{
        if(u == x.u) return v < x.v;
        return u < x.u;
    }
};
vector<edge> bridge;//存答案
//
void dfs(int u, int pre){
    vis[u] = 1;
    low[u] = ids[u] = ++id;
    for(int i=0; i<G[u].size(); i++){
        int v = G[u][i];
        if(v == pre) continue;
        if(!vis[v]){
            dfs(v , u);
            low[u] = min(low[u] , low[v]);
            //桥存在定理 
            if(ids[u] < low[v]){
                int uu = u, vv = v;
                //根据题意 这里需要把u调成小的
                if(uu > vv) swap(uu , vv);
                bridge.push_back(edge(uu,vv));
            }
        }
        else{
            low[u] = min(low[u] , ids[v]);
        }
    }
}

void findBrige(){
    id = 0;
    MS(low , 0);
    MS(vis , 0);
    bridge.clear();
    
    rep(i,0,n-1){
        if(!vis[i]) dfs(i, -1);
    }
}



int main(){
    while(sc(n)!=EOF){
        //if(n == 0) break;
        rep(i,0,n-1)  G[i].clear();
        rep(i,0,n-1){
            int u,k,v;
            scanf("%d (%d)",&u, &k);
            while(k--){
                sc(v);
                G[u].push_back(v);
            }
        }
        findBrige();
        sort(bridge.begin(),bridge.end());
        printf("%d critical links\n",bridge.size());
        for(int i=0; i<bridge.size(); i++){
            printf("%d - %d\n",bridge[i].u,bridge[i].v);
        }
        printf("\n");
    }
    return 0;
}
```
### 差分约束系统
- 转化为图上的最短路或者最长路
  - 不等号方向为 <= 最短路
  - 不等号方向为 >= 最长路

- 模板
```c++
const int M = 1e5+10;
int n,m;//顶点数边数
int head[maxn];//记录顶点的第一条边
int cnt; //记录当前是第几条边
//边
struct node{
    int to;
    int w;
    int nxt;
}edge[2*M]; //无向图的话要开两倍
//加边
void addEdge(int u, int v, int w){
    edge[cnt].to = v;
    edge[cnt].w = w;
    edge[cnt].nxt = head[u];
    head[u] = cnt++;
}

bool vis[maxn];//记录是否在队列
int dis[maxn];//记录当前最短距离
int in[maxn];//记录结点被入队了多少次，如果大于n则说明有负环
//int path[maxn];//记录前驱
bool SPFA(int s){
    queue<int> q;
    //把所有点一开始都丢进队列，事实上相当于建立一个虚源点，并限定定所有点到其距离为1，保证了所有变量值大于等于1
    rep(i, 1, n){
        q.push(i);
        dis[i] = 1;
        vis[i] = 1;
    }
    while(!q.empty()){
        int fr = q.front();
        q.pop();
        vis[fr] = 0;//出队后置为0
        //对每个与fr相连的顶点 对其进行松弛操作
        for(int i=head[fr]; i!=0; i=edge[i].nxt){
            int v = edge[i].to;
            int w = edge[i].w;
            //这里跑最长路 所以取小于号
            if(dis[v] < dis[fr] + w){
                //pre[v] = fr;
                dis[v] = dis[fr] +  w;
                if(!vis[v]){
                    q.push(v);
                    in[v]++;
                    vis[v] = 1;
                    if(in[v] > n) return false;
                }
            }
        }
    }
    return true;
}

int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    int u,v,w;
    cnt = 1;//第一条边
    MS(head , 0 );
    //rep(i,1,n) addEdge(0,i,1);
    rep(i , 1, m){
        cin>>w>>u>>v;
        if(w == 1){
            addEdge(u , v , 0);
            addEdge(v , u , 0);
        }
        else if(w == 2){
            addEdge(u , v, 1);
        }
        else if(w == 3){
            addEdge(v , u , 0);
        }
        else if(w == 4){
            addEdge(v, u, 1);
        }
        else if(w == 5){
            addEdge(u , v , 0);
        }
    }
    ll ans = 0;
    if(SPFA(0)){
        rep(i,1,n)
            ans += dis[i];
            cout<<ans<<endl;
    }
    else{
        cout<<-1<<endl;
    }
return 0;
}
```
### 2-sat
```c++
struct TwoSAT
{
    int n;
    vector<int> G[maxn*2];
    bool mark[maxn*2];//代表是否被选中 偶数 i i^1有且只有1个被选中
    int S[maxn*2],c;
    void init(int n)
    {
        this->n=n;
        for(int i=0; i<2*n; i++) G[i].clear(),mark[i] = 0;
    }

    void add_clause(int x,int xval,int y,int yval)
    {
        x=x*2+xval;
        y=y*2+yval;
        G[x].push_back(y^1);
        G[y].push_back(x^1);
    }
    
    bool dfs(int x)
    {
        if (mark[x^1]) return false; //节点已被访问，下同
        if (mark[x]) return true;
        mark[x]=true;  //标记xi
        S[c++]=x;
        for (int i=0; i < G[x].size(); i++) //邻接边搜索
            if (!dfs(G[x][i])) return false;
        return true;
    }

    bool solve()
    {
        for (int i=0; i<n*2; i+=2)
            if (!mark[i]&&!mark[i+1])
            {
                c=0;
                if (!dfs(i))//如果标记xi为假不成立，则从头标记xi为真
                {
                    while (c>0) mark[S[--c]]=false;//返回假设的起点
                    if (!dfs(i+1)) return false;//判断是否成立
                }
            }
        return true;
    }
}ts;

int n,m;
int main(){
    ios::sync_with_stdio(false);
    while(cin>>n>>m){
        ts.init(n);
        int x,xv,y,yv;
        rep(i,1,m){
            cin>>x>>y>>xv>>yv;
            ts.add_clause(x,xv,y,yv);
        }
        if(ts.solve()){
            cout<<"YES"<<endl;
        }
        else cout<<"NO"<<endl;
    }
    return 0;
}
```
### 网络流
- Dinic
```c++
#include<iostream>
#include<stdio.h>
#include<cstring>
#include<string>
#include<vector>
#include<math.h>
#include<queue>
#include<set>
#include<algorithm>
#include<map>
#define MS(x) memset(x,0,sizeof(x));
#define MS1(x) memset(x,-1,sizeof(x));
using namespace std;
const int maxN = 200;//点数
const int maxM =1e6;//边数必须得是给定边数的两倍 因为还有反向边
const int inf = 0x3f3f3f3f;
class Graph
{
//先Graph G 生成一个类
//然后G.init(n) n是点的个数
//然后addedge加边
//记得设置源点汇点 set_st(start,end);
//最后直接跑Dinic() 返回的就是最大流
private:
int s, t;//源点和汇点
int n;//点的个数
int cnt;//前向星
int Head[maxN];//每个点最后一条边的编号
int Next[maxM];//指向对应点的前一条边
int W[maxM];//每一条边的残量
int V[maxM];//每一条边指向的点
int Depth[maxN];//分层图的深度
int cur[maxN];//cur就是记录当前点u循环到了哪一条边
public:
void init(int n)//源点 汇点 点的个数
{
    cnt = -1;
    memset(Head, -1, sizeof(Head));
    memset(Next, -1, sizeof(Next));
    this->n = n;
}
void set_st(int source,int terminal)//设置源点 汇点
{
    s = source;
    t = terminal;
}
void _Add(int u, int v, int w)//前向星
{
    cnt++;
    Next[cnt] = Head[u];
    Head[u] = cnt;
    V[cnt] = v;
    W[cnt] = w;
}
void Add_Edge(int u, int v, int w)//前向星
{
    _Add(u, v, w);
    _Add(v, u, 0);
}
int dfs(int u, int flow)//u是当前节点,flow是当前流量
{
    if (u == t)//达到汇点 直接返回
        return flow;
    for (int& i = cur[u]; i != -1; i = Next[i])//注意这里的&符号，这样i增加的同时也能改变cur[u]的值，达到记录当前弧的目的
    {
        if ((Depth[V[i]] == Depth[u] + 1) && (W[i] != 0))//如果满足分层图条件并且参量不为0
        {
            int di = dfs(V[i], min(flow, W[i]));//向下增广
            if (di > 0)//增广成功
            {
                W[i] -= di;//正向边减
                W[i ^ 1] += di;//反向边加
                return di;//返回流量
            }
        }
    }
    return 0;//增广失败 返回0
}
bool bfs()
{
    queue<int> Q;
    while (!Q.empty()) Q.pop();
    MS(Depth);
    Depth[s] = 1;//源点的深度为1
    Q.push(s);
    while (!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        for (int i = Head[u]; i != -1; i = Next[i])
            if ((Depth[V[i]] == 0) && (W[i] > 0))//深度等于0并且残量大于0
            {
                Depth[V[i]] = Depth[u] + 1;//它就是下一层
                Q.push(V[i]);
            }
    } 
    if (!Depth[t]) return 0;//如果汇点的深度为0 也就是不存在增广路
    return 1;//汇点深度不为0 存在增广路
}
int Dinic()
{
    int Ans = 0;//纪录最大流量
    while (bfs())//存在增广路
    {
        for (int i = 1; i <= n; i++)//当前弧优化
            cur[i] = Head[i];
        while (int d = dfs(s, inf))//源点汇入inf的流量 当还能增广时 一直增加流量
        {
            Ans += d;
        }
    }
    return Ans;//返回流量
}
}G;
int cas = 1;
int t;
int main()
{
cin>>t;
while(t--){
    int n,m;
    cin>>n>>m;
    G.init(n);
    G.set_st(1,n);
    int u,v,w;
    for(int i=0;i<m;i++)
    {
        cin>>u>>v>>w;
        G.Add_Edge(u,v,w);
    }
    cout<<"Case "<<cas++<<": "<<G.Dinic()<<endl;
}
}
```
- 最小费用最大流
```c++
#include<iostream>
#include<stdio.h>
#include<cstring>
#include<string>
#include<vector>
#include<math.h>
#include<queue>
#include<set>
#include<algorithm>
#include<map>
#define MS(x) memset(x,0,sizeof(x));
using namespace std;
const int MAXN = 1e5 + 5;
const int INF = 0x3f3f3f3f;
struct Edge
{
int from, to, cap, flow, cost;       //起点,终点,容量,流量,花费
Edge(int u, int v, int c, int f, int w) :from(u), to(v), cap(c), flow(f), cost(w) {}
};
struct MCMF
{
    int n, m;                //结点数,边数(包括反向弧),源点s,汇点t
    vector<Edge> edges;            //边表。edges[e]和edges[e^1]互为反向弧
    vector<int> G[MAXN];           //邻接表，G[i][j]表示结点i的第j条边在edges数组中的序号
    bool inq[MAXN];                //是否在队列中
    int d[MAXN];                   //Bellman-Ford
    int p[MAXN];                   //上一条弧
    int a[MAXN];                   //可改进量

    void init(int n)
    {
        this->n = n;
        edges.clear();
        for (int i = 0; i <= n; i++) G[i].clear();
    }
    void add_edge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge(from, to, cap, 0, cost));
        edges.push_back(Edge(to, from, 0, 0, -cost));
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool BellmanFord(int s, int t, int &flow, long long& cost)
    {
        for (int i = 0; i <= n; i++) d[i] = INF;
        memset(inq, 0, sizeof(inq));
        d[s] = 0; inq[s] = true; p[s] = 0; a[s] = INF;

        queue<int> Q;
        Q.push(s);
        while (!Q.empty())
        {
            int u = Q.front(); Q.pop();
            inq[u] = 0;
            for (int i = 0; i < G[u].size(); i++)
            {
                Edge& e = edges[G[u][i]];
                if (e.cap > e.flow && d[e.to] > d[u] + e.cost)
                {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    a[e.to] = min(a[u], e.cap - e.flow);
                    if (!inq[e.to]) { Q.push(e.to); inq[e.to] = true; }
                }
            }
        }
        if (d[t] == INF) return false;
        flow += a[t];
        cost += (long long)d[t] * (long long)a[t];
        for (int u = t; u != s; u = edges[p[u]].from)
        {
            edges[p[u]].flow += a[t];
            edges[p[u] ^ 1].flow -= a[t];
        }
        return true;
    }

    int Mincost_Maxflow(int s, int t, long long& cost)
    {
        int flow = 0; cost = 0;
        while (BellmanFord(s, t, flow, cost));
        return flow;
    }

}solve;

```

## Tarjan
### Tarjan强连通分量

```c++
    int n;//顶点数 
    int ans;//
    struct node{
        int v,nxt;
    }edge[maxn*maxn];
    int head[maxn];
    int cnt;
    void addEdge(int u, int v){
        edge[cnt].v = v;
        edge[cnt].nxt = head[u];
        head[u] = cnt++;
    }


    int scc;
    int id;
    bool onStack[maxn];
    int dfn[maxn];//dfs序号
    int low[maxn];
    stack<int> stak;
    int color[maxn];//强连通分量染色

    int in[maxn];
    int out[maxn];

    void dfs(int u){
        stak.push(u);
        onStack[u] = 1;
        dfn[u] = low[u] = ++id;
        for(int i=head[u];  i; i=edge[i].nxt){
            int v = edge[i].v;
            if(!dfn[v]){
                dfs(v);	
                low[u] = min(low[u] , low[v]);
            } 
            else if(onStack[v]) low[u] = min(low[u] , dfn[v]);
        }
        if(dfn[u] == low[u]){
            scc++;
            while(true){
                int tp = stak.top();
                stak.pop();
                color[tp] = scc;//染色
                onStack[tp] = 0;
                if(tp == u) break; 
            }
        }
    } 

    void init(){
        cnt = 1;
        id = 0;
        scc = 0;
        memset(dfn , 0 ,sizeof dfn);
        memset(low , 0 ,sizeof low);
        memset(head , 0 ,sizeof head);
        memset(in , 0 ,sizeof in);
        memset(out , 0 ,sizeof out);
        memset(onStack , 0 ,sizeof onStack);
        while(!stak.empty()) stak.pop();	
    }
    void tarjan(){

        for(int i=1; i<=n; i++) if(!dfn[i]) dfs(i);
        //缩点后统计度数
        for(int u=1; u<=n; u++){
            for(int j=head[u]; j; j=edge[j].nxt){
                int v = edge[j].v;
                if(color[u] != color[v]){
                    out[color[u]]++;
                    in[color[v]]++;
                }
            }
        }
        int rout = 0, rin = 0;
        for(int i=1; i<=scc; i++){
            if(out[i] == 0) rout++;
            if(in[i] == 0) rin++;
        }
        ans = max(rin , rout);
        if(scc == 1) printf("1\n0\n");
        else printf("%d\n%d\n", rin , ans);
    }

```


### 割点

```c++
    const int maxn = 1e2+10;
    struct node{
        int to, next;
    }edge[maxn*maxn*2];

    int cnt, head[maxn];

    int idx, dfn[maxn], low[maxn];
    bool cut[maxn];

    void addEdge(int u, int v)
    {
        edge[cnt].to = v;
        edge[cnt].next = head[u];
        head[u] = cnt++;
    }

    void Tarjan(int u, int pre)
    {
        dfn[u] = low[u] = ++idx;
        int son = 0;
        for(int i = head[u]; i; i = edge[i].next)
        {
            int v = edge[i].to;
            if(v == pre) continue;
            if(!dfn[v])
            {
                son++;
                Tarjan(v, u);
                low[u] = min(low[u] , low[v]);
                if(u != pre && low[v] >= dfn[u])
                    cut[u] = true;
            }
            else
                low[u] = min(low[u], dfn[v]);
        }

        if(u==pre && son>1) cut[u] = true;
    }

    void init()
    {
        cnt = 1;
        memset(head, 0, sizeof(head));
        idx = 0;
        memset(dfn, 0, sizeof(dfn));
        memset(low, 0, sizeof(low));
        memset(cut, false, sizeof(cut));
    }

    int main()
    {
        int n;
        while(scanf("%d", &n) && n)
        {
            init();
            int u, v;
            while(scanf("%d", &u) && u)
            {
                while(getchar()!='\n')
                {
                    scanf("%d", &v);
                    addEdge(u, v);
                    addEdge(v, u);
                }
            }

            Tarjan(1, 1);
            int ans = 0;
            for(int i = 1; i<=n; i++)
                if(cut[i]) ans++;

            printf("%d\n", ans);
        }
    }

```

### 桥
- 防重边桥

```c++
    const int maxn = 1e3+10;
    int n,m;
    int ans;
    struct node{
        int to, next,w;
    }edge[maxn*maxn*2];

    int cnt, head[maxn];
    int son;
    int idx;//dfs计数 
    int dfn[maxn]; //表示dfs遍历到该节点的序号，也就是顺序值
    int low[maxn]; //表示当前顶点不通过父亲节点能访问到的祖先节点（父亲节点上面的节点）中的最小顺序值
    bool vis[maxn*maxn*2];//处理重边 

    void addEdge(int u, int v, int w)
    {
        edge[cnt].to = v;
        edge[cnt].w = w; 
        edge[cnt].next = head[u];
        head[u] = cnt++;
    }
    //以u为根节点dfs过程中产生一棵搜索树 
    void Tarjan(int u, int pre)
    {
        son++;
        dfn[u] = low[u] = ++idx;
        int k = 0;
        for(int i = head[u]; i!=-1; i = edge[i].next)
        {
            int v = edge[i].to;
            
            //重边考虑
            if(v == pre&& !k ) {
                k++;
                continue;
            }
            
            if(!dfn[v])
            {
                Tarjan(v, u);
                low[u] = min(low[u] , low[v]);

                if(low[v] > dfn[u] ){ //(u,v)边是桥 
                    ans = min(ans , edge[i].w);
                }
            } 
            else
                low[u] = min(low[u], dfn[v]);
        }
    }

    void init(){
        ans = 0x3f3f3f3f;
        cnt = 0;
        son = 0;
        idx = 0;
        for(int i=0; i<=n; i++){
            head[i] = -1;
            dfn[i] = low[i] = 0;
        }
        for(int i=0; i<=2*m; i++){
            vis[i] = 0;
        }
    }

    int main()
    {
        while(scanf("%d %d", &n,&m) && (n+m))
        {
            init();
            int u, v, w;
            for(int i=1; i<=m ;i++){
                scanf("%d %d %d",&u, &v,&w);
                addEdge(u , v, w);
                addEdge(v , u, w);
                
            } 
            Tarjan(1, -1);
    
            if(son != n) printf("0\n");
            else if(ans == 0x3f3f3f3f) printf("-1\n");
            else if(ans == 0) printf("1\n");
            else printf("%d\n",ans);  
        }
        return 0;
    }
```
- 缩点生成树 去除桥
```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<stack>
#include<queue>
#include<vector>
using namespace std;
#define maxn 20010

stack<int> stak;
vector<int> G[maxn];
 
int low[maxn],dfn[maxn];
int color[maxn];
bool onStack[maxn];
int degree[maxn];
int n,m,cnt,scc;
int idx;

void Tarjan(int u,int father)
{
    low[u] = dfn[u] = ++idx;
    onStack[u] = true;
    stak.push(u);
    int k = 0;
    for(int i=0; i<G[u].size(); i++){
        int v = G[u][i];
        //防重边
        if(v == father && !k){
        	k++;
        	continue;
		} 
        if(!dfn[v]){
            Tarjan(v,u);
            low[u] = min(low[u],low[v]);
        }
		else if(onStack[v]){
            low[u] = min(low[u],dfn[v]);
        }
    }
    if(low[u] == dfn[u]){
        int v;
        scc++;
        do{
            v=stak.top();
            stak.pop();
            onStack[v]=false;
            color[v]=scc;
        }while(u!=v);
    }
}

void init(){
	while(!stak.empty()) stak.pop();
	for(int i=1;i<=n;i++) G[i].clear();
    memset(low,0,sizeof(low));
    memset(dfn,0,sizeof(dfn));
    memset(onStack,false,sizeof(onStack));
    memset(degree,0,sizeof(degree));
    memset(color,0,sizeof(color));
    cnt = 0;
	scc = 0;
	idx = 0; 
}

int main()
{
    int u,v;
    while(~scanf("%d%d",&n,&m)){
        init();
        while(m--){
            scanf("%d%d",&u,&v);
            G[u].push_back(v);
            G[v].push_back(u);
        }
        for(int i=1;i<=n;i++){
            if(!dfn[i]) Tarjan(i,-1);
        }
        for(int i=1; i<=n; i++){
            for(int j=0;j<G[i].size();j++){
                if(color[i]!=color[G[i][j]]){
                    degree[color[i]]++;
                }
            }
        }
        for(int i=1;i<=scc;i++){
            if(degree[i] == 1) cnt++;
        }
        printf("%d\n",(cnt+1)/2);
    }
    return 0;
}

```

### 双连通分量
- 缩点重新建树 求树直径

```c++
    #define maxn 200010
    #define M 1000010
    stack<int> stak;
    //vector<int> G[maxn];
    int dia;//直径 
    int pos;//最远点位置 
    int cnt;
    int head[maxn];
    struct node{
        int nxt,v;
    }edge[M<<1];
    void addEdge(int u, int v){
        edge[cnt].v = v;
        edge[cnt].nxt = head[u];
        head[u] = cnt++;
    }

    int CNT;
    int HEAD[maxn];
    struct NODE{
        int nxt,v;
    }EDGE[M<<1];
    void ADDEDGE(int u, int v){
        EDGE[CNT].v = v;
        EDGE[CNT].nxt = HEAD[u];
        HEAD[u] = CNT++;
    }
    int low[maxn];
    int dfn[maxn];
    int color[maxn];
    bool onStack[maxn];
    int n,m,scc;
    int idx;
    //int Stack[maxn];
    int top;
    bool VIS[maxn];

    void Tarjan(int u,int father)
    {
        low[u] = dfn[u] = ++idx;
        onStack[u] = true;
        stak.push(u);
        int k = 0;
        for(int i=head[u]; i != -1; i=edge[i].nxt){
            int v = edge[i].v;
            //重边考虑 不止一条路到父亲 
            if(v == father && !k){
                k++;
                continue;
            } 
            if(!dfn[v]){
                Tarjan(v,u);
                low[u] = min(low[u],low[v]);
            }
            else if(onStack[v]){
                low[u] = min(low[u],dfn[v]);
            }
        }
        if(low[u] == dfn[u]){
            int v;
            scc++;
            do{
                v=stak.top();
                stak.pop();
                onStack[v]=false;
                color[v]=scc;
            }while(u!=v);
        }
    }

    void init(){
        while(!stak.empty()) stak.pop();
        
        for(int i=0; i<=n; i++){
            low[i] = dfn[i] = onStack[i] = color[i] = 0;
            head[i] = HEAD[i] = -1;
            VIS[i] = 0;
        }
        cnt = CNT = 0;
        scc = 0;
        idx = 0; 
        dia = 0; 
        top = 0; 
    }

    void dfs2(int u, int d){
        VIS[u] = 1;
        if(d > dia){
            dia = d;
            pos = u;
        }
        for(int i=HEAD[u]; i!= -1; i=EDGE[i].nxt){
            int v = EDGE[i].v;
            if(VIS[v]) continue;
            dfs2(v , d+1);
        }
    } 

    int main()
    {
        int u,v;
        while(~scanf("%d%d",&n,&m) && (n+m)!=0){
            init();
            while(m--){
                scanf("%d%d",&u,&v);
                addEdge(u , v);
                addEdge(v , u); 
            }
            for(int i=1;i<=n;i++){
                if(!dfn[i]) Tarjan(i,-1);
            }
            //缩点重新建图 
            for(int i=1; i<=n; i++){
                for(int j=head[i];j!=-1;j=edge[j].nxt){
                    if(color[i] != color[edge[j].v] ){
                        ADDEDGE(color[i] , color[edge[j].v]);
                        ADDEDGE(color[edge[j].v] , color[i]);
                    }
                }
            }

            dia = 0;
            dfs2(1 ,  0);
            dia = 0;
            for(int i=0; i<=n; i++) VIS[i] = 0;
            
            dfs2(pos , 0);
            printf("%d\n",scc-1-dia);
        }
        return 0;
    }
```

## 树链剖分
### 树上修改查询
```c++
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;
const int maxn = 1e5+10;

int n,m,r;//顶点数 操作个数 根节点  
int p ; //模数
//链式前向星建图 
int head[maxn];
int cnt;
struct edge{
    int v,w,nxt;
}edge[maxn<<1];

void addEdge(int u, int v){
    edge[++cnt].v = v;
    edge[cnt].nxt = head[u];
    head[u] = cnt;
}

int siz[maxn];//子树大小 
int top[maxn];//重链顶端 
int son[maxn];//重儿子 
int dep[maxn];//结点深度 
int fa[maxn];//结点父亲 
int idx[maxn];//dfs序号对应结点 
int rk[maxn];//结点对应dfs序号 
int dfn;//dfs时序 
int s[maxn<<2],e[maxn<<2];//区间左右端点 
ll sum[maxn<<2];//区间和
int lazy[maxn<<2]; //懒标记 

int a[maxn];//原树的点权值数组
int b[maxn];//重新编号后的点权值数组 

void init(){
    memset(head , 0 ,sizeof head);
    memset(son , 0 ,sizeof son);
    cnt = 0;
    dfn = 0;
}
//处理出size fa dep数组  son数组根据siz确定 
void dfs1(int u, int f, int d){
    dep[u] = d;
    fa[u] = f;
    siz[u] = 1;
    for(int i=head[u]; i ; i=edge[i].nxt){
        int v = edge[i].v;  
        if(v == f) continue;
        dfs1(v , u, d+1);
        siz[u] += siz[v];
        if(!son[u] || siz[son[u]] < siz[v]) son[u] = v;
    }

} 
//处理出top idx rk数组 
void dfs2(int u, int t){
    top[u] = t;
    idx[u] = ++dfn;
    a[dfn] = b[u];//把u结点的权值重新赋值到dfs序列中
    rk[dfn] = u; 
    if(!son[u]) return ;//如果没有重儿子则返回
    dfs2(son[u] , t);//同一条重链上的结点拥有同一个top 
    for(int i=head[u]; i; i=edge[i].nxt){
        int v = edge[i].v;
        if(v != son[u] && v != fa[u]){ //如果当前结点不是重儿子 则其top等于自己 
            dfs2( v , v ); 
        }
    } 
}

//线段树相关
void pushUp(int rt){
    sum[rt] = (sum[rt<<1] + sum[rt<<1|1]) % p;
}
void build(int rt, int l , int r){
    s[rt] = l, e[rt] = r;
    lazy[rt] = 0;
    if(l == r){
        sum[rt] = a[l];
        return ;
    }
    int mid = (l + r) >> 1;
    build(rt<<1 , l , mid);
    build(rt<<1|1, mid+1, r);
    pushUp(rt);
} 

void pushDown(int rt){
    if(lazy[rt] != 0 && s[rt] != e[rt]){
        sum[rt<<1] += lazy[rt] * (e[rt<<1] - s[rt<<1] + 1);
        sum[rt<<1|1] += lazy[rt] * (e[rt<<1|1] - s[rt<<1|1] + 1) ;

        sum[rt<<1] %= p;
        sum[rt<<1|1] %= p;

        lazy[rt<<1] += lazy[rt];
        lazy[rt<<1|1] += lazy[rt];

        lazy[rt<<1] %= p;
        lazy[rt<<1|1] %= p;

        lazy[rt] = 0;
    }

}

void update(int rt, int l, int r, int val){
    if(s[rt] == l && e[rt] == r){
        sum[rt] += val*(e[rt] - s[rt] + 1);
        sum[rt] %= p;
        lazy[rt] += val;
        lazy[rt] %= p;
        return ;
    }

    pushDown(rt);
    int mid = (s[rt] + e[rt]) >> 1;
    if(l > mid)    update(rt<<1|1, l , r , val);
    else if(r <= mid) update(rt<<1, l , r, val);
    else{
        update(rt<<1, l , mid, val);
        update(rt<<1|1, mid+1, r, val);
    }
    pushUp(rt);
}

ll query(int rt, int l, int r){
    //ll ans = 0;
    if(s[rt] == l && e[rt] == r)    return sum[rt];
    pushDown(rt);
    int mid = (s[rt] + e[rt]) >> 1;
    if(l > mid) return query(rt<<1|1,l,r);
    else if(r <= mid) return query(rt<<1,l,r);
    else return (query(rt<<1,l,mid) + query(rt<<1|1, mid+1,r)) % p;
}

//路径查询
ll queryRange(int x, int y){
    ll ans = 0;
    while(top[x] != top[y]){
        if(dep[top[x]] < dep[top[y]]) swap(x , y);
        ans += query(1, idx[top[x]] , idx[x]);
        ans %= p;
        x = fa[top[x]];
    }

    //若x ,y不在同一点则还需要把这一条重链的点权加上 
    if(dep[x] > dep[y]) swap(x , y);
    ans += query(1 , idx[x] , idx[y]);
    ans %= p;
    return ans; 
}
//更新路径
void updateRange(int x, int y, int k){
    k %= p;
    while(top[x] != top[y]){
        if(dep[top[x]] < dep[top[y]]) swap(x , y);
        update(1, idx[top[x]] , idx[x], k);
        x = fa[top[x]];
    }

    //若x ,y不在同一点则还需要把这一条重链的点权加上 
    if(dep[x] > dep[y]) swap(x , y);

    //由于x的深度小于y 而x,y又处于同一条链上 所以idx[x] < idx[y] 
    update(1 , idx[x] , idx[y] , k);
}
//查子树
ll querySon(int x){
    return query(1 , idx[x] , idx[x] + siz[x] - 1);
} 
//更新子树
void updateSon(int x ,int k){
    update(1 , idx[x] , idx[x] + siz[x] - 1, k);
}

int main(){
    int u,v,w,op;
    while(scanf("%d %d %d %d",&n,&m,&r,&p) != EOF){
        init();
        //读入点权 
        for(int i=1; i<=n; i++) scanf("%d",&b[i]);
        //建图 
        for(int i=1; i<n; i++){
            scanf("%d %d", &u, &v);
            addEdge(u , v);
            addEdge(v , u); 
        }
        dfs1(r , 0, 1);
        dfs2(r , r);
        build(1 , 1, n);
        for(int i=1; i<=m; i++){
            scanf("%d" ,&op);
            if(op == 1){
                scanf("%d %d %d", &u,&v,&w);
                updateRange(u , v, w);
            }
            else if(op == 2){
                scanf("%d %d", &u, &v);
                printf("%lld\n",queryRange(u , v));
            }
            else if(op == 3){
                scanf("%d %d", &u, &w);
                updateSon(u ,w);
            }
            else{
                scanf("%d",&u);
                printf("%lld\n",querySon(u));
            }
        }
    } 
    return 0;
}

```
### 树链剖分求LCA

```c++
#include<iostream>
#include<cstring>
using namespace std;
const int maxn = 5e5+10;

int n,m,s;//顶点数 询问次数 树根 

//链式前向星建图 
int head[maxn];
int cnt;
struct edge{
    int v,w,nxt;
}edge[maxn<<1];

void addEdge(int u, int v){
    edge[++cnt].v = v;
    edge[cnt].nxt = head[u];
    head[u] = cnt;
}

int siz[maxn];//子树大小 
int top[maxn];//重链顶端 
int son[maxn];//重儿子 
int dep[maxn];//结点深度 
int fa[maxn];//结点父亲 
int idx[maxn];//dfs序号对应结点 
int rk[maxn];//结点对应dfs序号 
int dfn;//dfs时序 

void init(){
    memset(head , 0 ,sizeof head);
    memset(son , 0 ,sizeof son);
    cnt = 0;
    dfn = 0;
}
//处理出size fa dep数组  son数组根据siz确定 
void dfs1(int u, int f, int d){
    dep[u] = d;
    fa[u] = f;
    siz[u] = 1;
    for(int i=head[u]; i ; i=edge[i].nxt){
        int v = edge[i].v;  
        if(v == f) continue;
        dfs1(v , u, d+1);
        siz[u] += siz[v];
        if(!son[u] || siz[son[u]] < siz[v]) son[u] = v;
    }

} 
//处理出top idx rk数组 
void dfs2(int u, int t){
    top[u] = t;
    idx[u] = ++dfn;
    rk[dfn] = u;
    if(!son[u]) return ;//如果没有重儿子则返回
    dfs2(son[u] , t);//同一条重链上的结点拥有同一个top 
    for(int i=head[u]; i; i=edge[i].nxt){
        int v = edge[i].v;
        if(v != son[u] && v != fa[u]){ //如果当前结点不是重儿子 则其top等于自己 
            dfs2( v , v ); 
        }
    } 
}

int LCA(int x, int y){
    while(top[x] != top[y]){
        if(dep[top[x]] > dep[top[y]]){
            x = fa[top[x]];
        }
        else{
            y = fa[top[y]];
        }
    }
    return  dep[x] < dep[y] ? x : y;
} 

int main(){
    int u,v;
    while(scanf("%d%d%d",&n,&m,&s) != EOF){
        init();
        for(int i=1; i<n; i++){
            scanf("%d %d", &u, &v);
            addEdge(u , v);
            addEdge(v , u); 
        }
        dfs1(s , 0, 1);
        dfs2(s , s);
        for(int i=1; i<=m; i++){
            scanf("%d %d", &u, &v);
            printf("%d\n",LCA(u,v));
        }
    } 
} 
```

## 树上差分
### 点差分
```c++
cf[s]++;
cf[t]++;
cf[lca(s,t)]--;
cf[ father[lca(s,t)] ]--;
```
```c++

int t,n,k;
vector<int> G[maxn];
int s,e,lca;
int depth[maxn];//记录每个结点的深度 根节点深度为0
int fa[maxn][20];//fa[i][j]表示i结点向上爬 2^j是哪个结点

int ans = -1;//最终答案 
int value[maxn];//每个结点的点权 


//预处理出每个结点的深度和其直接父节点
void dfs(int u, int pre, int d){
    fa[u][0] = pre;//向上一个当然是直接父节点 pre
    depth[u] = d;//深度
    for(int i=0; i<G[u].size(); i++){
        int v = G[u][i];
        if(v != pre){
            dfs(v , u, d+1);
        }
    }
}
//倍增预处理出fa数组
void init(){
    //有点区间DP的意思
    for(int j=0; (1<<(j+1))<n; j++){
        for(int i=1; i<=n; i++){
            if(fa[i][j] < 0) fa[i][j+1] = -1;
            else fa[i][j+1] = fa[fa[i][j]][j];
        }
    }
}
//给定俩个结点在线求其LCA
int LCA(int u, int v){
    //保证v是较深的点
    if(depth[u] > depth[v]) swap(u , v);
    int temp = depth[v] - depth[u];//深度差
    //先把v调到与u等高处
    for(int i=0; (1<<i)<=temp; i++){
        if((1<<i) & temp) v = fa[v][i];
    }
    if(u==v) return u;
    //然后两个人比翼双飞
    for(int i=(int)(log(1.0*n)/log(2.0)); i >= 0; i--){
        if(fa[u][i] != fa[v][i]){
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];

}

//遍历差分 
void dfs2(int u, int f){
    for(int i=0; i<G[u].size(); i++){
        int v = G[u][i];
        if(v == f) continue;
        dfs2(v , u);
        value[u] += value[v];
    }
    if(value[u] > ans) ans = value[u];
}


int main(){
    int u,v;
    while(sc2(n,k) != EOF){
        MS(value , 0);
        rep(i , 1, n) G[i].clear();
        rep(i , 1, n-1){
            sc2(u,v);
            G[u].push_back(v);
            G[v].push_back(u);
        }
        dfs(1 , 0 , 1) ;//初始化LCA 
        init(); 
        for(int i=1; i<=k; i++){
            sc2(u , v);
            value[u]++;
            value[v]++;
            int lca = LCA(u,v);
            value[lca]--;
            value[fa[lca][0]]--;
        }

        dfs2(1 , 0);
        pfd(ans);
    }
    return 0;
}
```




### 边差分

```c++
cf[s]++;
cf[t]++;
cf[lca(s,t)] -= 2;
```

```c++
int t,n,k;

int head[maxn];//head数组 
int cnt;//边数 
int dist[maxn];//点i到根节点的路径长度 
int cf[maxn];//cf[i]表示i到father[i]这条边被经过了多少次
int dis[maxn];//dis[i]表示第i个路径的总长度 
int mx;//最长路径长度 
int me;//最长边 
int ans;//最终结果 
struct node{
    int v;
    int nxt;
    int w;
}edge[maxn<<1];

int lca[maxn]; //存第i个路径两端点的LCA 
int depth[maxn];//记录每个结点的深度 根节点深度为0
int fa[maxn][20];//fa[i][j]表示i结点向上爬 2^j是哪个结点
int l[maxn],r[maxn];//存路径端点 

void Init(){
    cnt = 1;
    mx = me = -1; 
    rep(i , 0 , n){
        head[i] = 0;
        dis[i] = 0; 
    }
}
void addEdge(int u, int v, int w){
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].nxt = head[u];
    head[u] = cnt++;
}
//预处理出每个结点的深度和其直接父节点
void dfs(int u, int pre, int d){
    fa[u][0] = pre;//向上一个当然是直接父节点 pre
    depth[u] = d;//深度
    for(int i=head[u]; i; i=edge[i].nxt){
        int v = edge[i].v;
        if(v != pre){
            dist[v] = dist[u] + edge[i].w;
            dfs(v , u, d+1);
        }
    }
}
//倍增预处理出fa数组
void init(){
    //有点区间DP的意思
    for(int j=0; (1<<(j+1))<n; j++){
        for(int i=1; i<=n; i++){
            if(fa[i][j] < 0) fa[i][j+1] = -1;
            else fa[i][j+1] = fa[fa[i][j]][j];
        }
    }
}
//给定俩个结点在线求其LCA
int LCA(int u, int v){
    //保证v是较深的点
    if(depth[u] > depth[v]) swap(u , v);
    int temp = depth[v] - depth[u];//深度差
    //先把v调到与u等高处
    for(int i=0; (1<<i)<=temp; i++){
        if((1<<i) & temp) v = fa[v][i];
    }
    if(u==v) return u;
    //然后两个人比翼双飞
    for(int i=(int)(log(1.0*n)/log(2.0)); i >= 0; i--){
        if(fa[u][i] != fa[v][i]){
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];

}

//遍历差分 
void dfs2(int u, int f){
    for(int i=head[u]; i; i=edge[i].nxt) {
        int v = edge[i].v;
        if(v == f) continue;
        dfs2(v , u);
        cf[u] += cf[v];
    }
}

//这条边必须出现了ct次， 并且它的长度不小于len 
bool dfsCheck(int u, int f, int ct, int len){
    for(int i=head[u]; i ; i=edge[i].nxt){
        int v = edge[i].v;
        if(v == f) continue;
        if(cf[v] == ct && edge[i].w >= len) return 1;
        if(dfsCheck(v , u, ct , len)) return 1;
    } 
    return 0;//根节点返回还找不到，那就不存在这样的公共边 
}

bool judge(int ans){
    int ct = 0;//路径长度超过ans的路径个数
    MS(cf , 0);//把各点经过的次数清零 
    if(ans >= mx) return 1;//如果当前答案大于等于最长路径 肯定行
    rep(i , 1, k) { //寻找哪些路径长度大于当前ans，找到，求是否存在一条比较长的公共边使得减去后mx小于等于ans 
        if(dis[i] > ans){
            ct++;
            cf[l[i]]++;
            cf[r[i]]++;
            cf[lca[i]] -= 2;
        }
    }
    //重新计算
    dfs2(1 , 0); //计算在这些超过ans长度的路径中，每条边被经过的次数 
    return dfsCheck(1 , 0, ct , mx - ans); 
} 

int main(){
    int u,v,w;
    while(sc2(n,k) != EOF){
        Init();
        //建树 
        rep(i , 1, n-1){
            sc2(u,v);
            sc(w);
            addEdge(u,v,w);
            addEdge(v,u,w);
            me = max(me , w); 
        }

        dfs(1 , 0 , 1) ;//初始化LCA 
        init(); //初始化LCA

        //读取路径 
        rep(i , 1, k){
            sc2(u , v);
            l[i] = u;
            r[i] = v; 
            lca[i] = LCA(u,v);
            dis[i] = dist[u] + dist[v] - 2*dist[lca[i]] ;//求该路径的长度 
            mx = max(mx , dis[i]);//求出最长路径 
        }

        int lo = mx - me;
        int hi = mx + 1;
        while(lo <= hi){
            int mid = (lo + hi) / 2;
            if(judge(mid)){
                hi = mid - 1;
                ans = mid;
            } 
            else{
                lo = mid + 1;
            }
        }

        pfd(ans);
    }
    return 0;
}
```




## 字符串
### KMP
```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 1000002;
int next[N];
char S[N], T[N];
int slen, tlen;

void getNext()
{
    int j, k;
    j = 0; k = -1; next[0] = -1;
    while(j < tlen)
        if(k == -1 || T[j] == T[k])
            next[++j] = ++k;
        else
            k = next[k];

}
/*
返回模式串T在主串S中首次出现的位置
返回的位置是从0开始的。
若返回-1则没有找到匹配
*/
int KMP()
{
    int i = 0, j = 0;
    getNext();

    while(i < slen && j < tlen)
    {
        if(j == -1 || S[i] == T[j])
        {
            i++; j++;
        }
        else
            j = next[j];
    }
    if(j == tlen)
        return i - tlen;
    else
        return -1;
}
/*
返回模式串在主串S中出现的次数
*/
int KMP_Count()
{
    int ans = 0;
    int i, j = 0;
    getNext();
    for(i = 0; i < slen; i++)
    {
        while(j > 0 && S[i] != T[j])
            j = next[j];
        if(S[i] == T[j])
            j++;
        if(j == tlen)
        {
            ans++;
            j = next[j];
        }
    }
    return ans;
}

int main()
{
    
    int TT;
    int i, cc;
    cin>>TT;
    while(TT--)
    {
        cin>>S>>T;
        slen = strlen(S);
        tlen = strlen(T);
        cout<<"模式串T在主串S中首次出现的位置: "<<KMP()<<endl;
        cout<<"模式串T在主串S中出现的次数: "<<KMP_Count()<<endl;
    }
    return 0;
}
```
### 马拉车

- 马拉车（Manacher）算法是在O（n）时间内解决寻找源字符串的最长回文子串S的问题的算法。
- 模板
```c++
//返回源字符串S的最长回文子串 
string Manacher(string s){
    //预处理源串 
    string t = "$#";
    for(int i=0; i<s.size(); i++){
        t+=s[i];
        t+="#";
    }
    //新建p数组,大小和t串一致，初始化为0 ，p[i]表示以t[i]为中心的回文串半径 
    vector<int> p(t.size() , 0); 
    
    //设定重要参数 mx(某回文串延伸到的最右边下标),id(mx所属回文串中心下标),
    //reCenter（结果最大回文串中心下标）,reLen（最大长回文长度） 
    int mx = 0, id = 0, reCenter = 0, reLen = 0;
    
    //遍历t字符串
    for(int i=1; i<t.size(); i++){
        //核心算法 
        p[i] = mx > i ? min(mx - i , p[2*id - i]) : 1;
        
        //上面的语句只能确定i~mx的回文情况，至于mx之后的部分是否对称，就只能老老实实去匹配了，匹配一个p[i]++ 
        while(t[i + p[i]] == t[i - p[i]]) p[i]++;
        
        //当t[i]匹配的 右边界超过mx时mx和id就更新 
        if(i+p[i] > mx){
            mx = i+p[i];
            id = i;
        }
        //更新结果数据 
        if(p[i] > reLen){
            reLen = p[i];
            reCenter = i;    
        }
    }
    
    return s.substr((reCenter - reLen) / 2 , reLen - 1)  ;
    
}
```


## 高精度
```java
import java.math.BigInteger;
import java.math.BigDecimal ;
import java.util.Scanner;
import java.util.Arrays;
    //对常数开方保留多位小数，返回高精度小数
private static BigDecimal sqrt(BigDecimal x, int n) {
    BigDecimal ans = BigDecimal.ZERO;
    BigDecimal eps = BigDecimal.ONE;
    for (int i = 0; i < n; ++i) {
        while (ans.pow(2).compareTo(x) < 0) {
            ans = ans.add(eps);
        }
        ans = ans.subtract(eps);
        eps = eps.divide(BigDecimal.TEN);
    }
    return ans;
}
public class Main {
	public static void main(String[] args) {//
		Scanner sc = new Scanner(System.in);
		int n;
		
		BigInteger mul = BigInteger.ONE;
		BigInteger ans = BigInteger.ZERO;
		n = sc.nextInt();
		P[] peop = new P[n+1];
		
		for(int i=0; i<=n; i++) {
			peop[i] = new P();
			peop[i].l = sc.nextInt();
			peop[i].r = sc.nextInt();
		}
		Arrays.sort(peop,1,n+1);
		for(P x : peop) {
			System.out.println(x);
		}
		for(int i=1; i<=n; i++) {
			mul = mul.multiply(BigInteger.valueOf(peop[i-1].l));
			if(ans.compareTo(mul.divide(BigInteger.valueOf(peop[i].r))) < 0) {
				ans = mul.divide(BigInteger.valueOf(peop[i].r));
			}
		}
		System.out.println(ans);
         //计算(bk - ak ) * (1+sqrt(5))/2 == ak是否成立 左边向下取整
        //     if( b.subtract(a).multiply(c).setScale(0, BigDecimal.ROUND_DOWN).equals(a)) {
        //         System.out.println(0);
        //     }
        //     else
        //         System.out.println(1);
        // }
	}
}

class P implements Comparable{
	int l,r;
	@Override
	public int compareTo(Object arg0) {
		// TODO Auto-generated method stub
		P p = (P) arg0;
		if(this.l * this.r < p.l * p.r) return -1;
		else if(this.l * this.r > p.l * p.r) return 1;
		return 0;
	}
	public String toString() {
		String ans = l + " " + r;
		return ans;
	}
	
}
```

## 数据结构

### 线段树
- 区间最值
```c++
#include<iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
typedef long long ll;
const int maxn = 100010;
const int inf = 0x3f3f3f3f;
int n , m;
int s[maxn<<2],e[maxn<<2];//区间左右端点 
int maxx[maxn<<2];//区间最大值 
int minx[maxn<<2];//区间最大值
int lazy[maxn<<2]; //懒标记 
ll a[maxn];//原数组

void pushUp(int rt){
    maxx[rt] = max(maxx[rt<<1] , maxx[rt<<1|1]);
    minx[rt] = min(minx[rt<<1] , minx[rt<<1|1]);
}
void build(int rt, int l , int r){
    s[rt] = l, e[rt] = r;
    lazy[rt] = 0;
    if(l == r){
        maxx[rt] = minx[rt] = a[l];
        return ;
    }
    int mid = (l + r) >> 1;
    build(rt<<1 , l , mid);
    build(rt<<1|1, mid+1, r);
    pushUp(rt);
} 

void pushDown(int rt){
    if(lazy[rt] != 0 && s[rt] != e[rt]){
        maxx[rt<<1] += lazy[rt];
        minx[rt<<1|1] += lazy[rt];
        
        lazy[rt<<1] += lazy[rt];
        lazy[rt<<1|1] += lazy[rt];
        lazy[rt] = 0;
    }    
}
void update(int rt, int l, int r, int val){
    if(s[rt] == l && e[rt] == r){
        minx[rt] += val;
        maxx[rt] += val;
        lazy[rt] += val;
        return ;
    }
    pushDown(rt);
    int mid = (s[rt] + e[rt]) >> 1;
    if(l > mid)    update(rt<<1|1, l , r , val);
    else if(r <= mid) update(rt<<1, l , r, val);
    else{
        update(rt<<1, l , mid, val);
        update(rt<<1|1, mid+1, r, val);
    }
    pushUp(rt);
}

int queryMin(int rt, int l, int r){
    //ll ans = 0;
    if(s[rt] == l && e[rt] == r)    return minx[rt];
    pushDown(rt);
    int mid = (s[rt] + e[rt]) >> 1;
    if(l > mid) return queryMin(rt<<1|1,l,r);
    else if(r <= mid) return queryMin(rt<<1,l,r);
    else return min(queryMin(rt<<1,l,mid) , queryMin(rt<<1|1, mid+1,r));
}

int queryMax(int rt, int l, int r){
    //ll ans = 0;
    if(s[rt] == l && e[rt] == r)    return maxx[rt];
    pushDown(rt);
    int mid = (s[rt] + e[rt]) >> 1;
    if(l > mid) return queryMax(rt<<1|1,l,r);
    else if(r <= mid) return queryMax(rt<<1,l,r);
    else return max(queryMax(rt<<1,l,mid) , queryMax(rt<<1|1, mid+1,r));
}

```
- 区间修改区间和
```c++
#include<iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
typedef long long ll;
const int maxn = 100010;
const int inf = 0x3f3f3f3f;
int n , m;
int s[maxn<<2],e[maxn<<2];//区间左右端点 
int sum[maxn<<2];
int lazy[maxn<<2]; //懒标记 

void pushUp(int rt){
    sum[rt] = sum[rt<<1|1] + sum[rt<<1];
}
void build(int rt, int l , int r){
    s[rt] = l, e[rt] = r;
    lazy[rt] = 0;
    if(l == r){
        sum[rt] = 1;
        return ;
    }
    int mid = (l + r) >> 1;
    build(rt<<1 , l , mid);
    build(rt<<1|1, mid+1, r);
    pushUp(rt);
} 

void pushDown(int rt){
    //  = or +=
    if(lazy[rt] != 0 && s[rt] != e[rt]){
        sum[rt<<1] = lazy[rt] * (e[rt<<1] - s[rt<<1] + 1);
        sum[rt<<1|1] = lazy[rt] * (e[rt<<1|1] - s[rt<<1|1] + 1);
        lazy[rt<<1] = lazy[rt];
        lazy[rt<<1|1] = lazy[rt];
        lazy[rt] = 0;
    }    
}
void update(int rt, int l, int r, int val){
    if(s[rt] == l && e[rt] == r){
        //= or +=
        sum[rt] = val * (e[rt] - s[rt] + 1);
        lazy[rt] = val;
        return ;
    }
    pushDown(rt);
    int mid = (s[rt] + e[rt]) >> 1;
    if(l > mid)    update(rt<<1|1, l , r , val);
    else if(r <= mid) update(rt<<1, l , r, val);
    else{
        update(rt<<1, l , mid, val);
        update(rt<<1|1, mid+1, r, val);
    }
    pushUp(rt);
}

int query(int rt, int l, int r){
    //ll ans = 0;
    if(s[rt] == l && e[rt] == r)    return sum[rt];
    pushDown(rt);
    int mid = (s[rt] + e[rt]) >> 1;
    if(l > mid) return query(rt<<1|1,l,r);
    else if(r <= mid) return query(rt<<1,l,r);
    else return query(rt<<1,l,mid) + query(rt<<1|1, mid+1,r);
}
```

- 离散化线段树
```c++
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<cstdio>
#include<queue>
using namespace std;
typedef long long ll;
const int maxn = 1e4 + 5;
//注意这里的maxn要乘2所以左移三位
bool vis[2*maxn];
int s[maxn<<3] , e[maxn<<3];
int color[maxn<<3];
int L[maxn] , R[maxn];
vector<int> v;
int ans;
int getId(int x){
    return lower_bound(v.begin() , v.end(), x) - v.begin() + 1;
}

void build(int rt, int l , int r){
    s[rt] = l;
    e[rt] = r;
    color[rt] = 0;
    if(l == r)    return ;
    int mid = ( l + r) >> 1;
    build(rt<<1 , l , mid);
    build(rt<<1|1, mid + 1, r);
}

void pushDown(int rt){
    if(color[rt] != 0){
        color[rt<<1] = color[rt];
        color[rt<<1|1] = color[rt];
        color[rt] = 0;
        return;
    }
}

void update(int rt, int l , int r , int val){
    if(s[rt] == l && e[rt] == r){
        color[rt] = val;
        return ;
    }
    pushDown(rt);
    int mid = (s[rt] + e[rt]) >> 1;
    if(l > mid) update(rt<<1|1 , l , r , val);
    else if(r <= mid)    update(rt<<1, l , r, val);
    else{
        update(rt<<1, l ,mid, val);
        update(rt<<1|1, mid+1, r, val);
    }
}

void query(int rt, int l , int r){
    if(color[rt] != 0){
        if(!vis[color[rt]]){
            vis[color[rt]] = 1;
            ans++;
            
        }
        return;
    }
    if(l == r)    return ;
    pushDown(rt);
    int mid = (s[rt] + e[rt]) >> 1;
    if(l > mid)    query(rt<<1|1, l,r);
    else if(r <= mid)    query(rt<<1,l,r);
    else{
        query(rt<<1,l,mid);
        query(rt<<1|1,mid+1,r);
    }
    
}

int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        ans = 0;
        memset(vis, 0, sizeof vis);
        v.clear();
        int n;
        scanf("%d",&n);
        int x,y;
        for(int i=0; i<n; i++){
            scanf("%d%d",&x,&y);
            v.push_back(x);
            v.push_back(y+1);
            L[i] = x;
            R[i] = y+1;
        }
        sort(v.begin() , v.end());
        v.erase(unique(v.begin() , v.end()) , v.end());
        
        build(1,1,v.size());
        
        
        for(int i=0; i<n; i++){
            update(1, getId(L[i]) , getId(R[i]) - 1, i+1);
        }
        
        query(1,1,v.size());
        printf("%d\n",ans);
    }
}
```

### 单调队列
- deque

```c++
 #include<iostream>
    #include<deque> 
    using namespace std;
    const int maxn = 1e6+10;
    deque<int> q;
    int a[maxn];
    int main(){
        ios::sync_with_stdio(false);
        int n,k;
        while(cin>>n>>k){
            for(int i=1; i<=n; i++) cin>>a[i];
            //最小值 维护单调增队列 
            for(int i=1; i<=n; i++){
                //遇到更小的就往前挤 
                while(!q.empty() && a[q.back()] > a[i] ) q.pop_back();
                q.push_back(i);
                //删除头 保证front的位置处于滑动窗口内 即 [i-k+1 , i] 
                //这种情况只可能在 i>=k 时才需要考虑 
                if(i >= k){
                    while(!q.empty() && q.front() <= i-k) q.pop_front();
                    //打印最小值
                    cout<<a[q.front()]<<" "; 
                } 
            }
            cout<<endl;
            //q.erase(q.begin(),q.end());
            while(!q.empty()) q.pop_back();
            //最大值  维护单调减队列 
            for(int i=1; i<=n; i++){
                //遇到大的就往前挤 
                while(!q.empty() && a[q.back()] < a[i] ) q.pop_back();
                q.push_back(i);
                //删除头 保证front的位置处于滑动窗口内 即 [i-k+1 , i] 
                //这种情况只可能在 i>=k 时才需要考虑 
                if(i >= k){
                    while(!q.empty() && q.front() <= i-k) q.pop_front();
                    //打印最大值
                    cout<<a[q.front()]<<" "; 
                } 
            }
            cout<<endl;
            
        }
        
    }
```


## 筛表
### 质数普通筛
```c++
const int maxn = 1e7;
bool isPrime[maxn+10];
int prime[maxn+10];
int count = 0;


//普通筛法 
void getPrime(){
    memset(isPrime, 1, sizeof isPrime);
    isPrime[1] = isPrime[0] = 0;
    //筛出bool数组 
    for(int i=2; i*i<=maxn; i++){ //如果想在这里直接把素数打入prime数组里那么这里i<maxn 
        if(isPrime[i]){
            for(int j=2; j<=maxn/i; j++){
                isPrime[i*j] = 0;
            }
        }
    }
    //根据bool数组把素数打入素数表 ，如果只要判断素数则以下代码可注释 
//    for(int i=0; i<maxn; i++){
//        if(isPrime[i])
//            prime[count++] = i;    
//    }    
}
```

### 质数线性筛
```c++

//线性筛法
bool check[maxn + 10];
int prime2[maxn + 10];
int count2 = 0; 
void getPrime2(){
    memset(check, 1, sizeof check);
    check[0] = check[1] = 0;
    for(int i=2; i<=maxn; i++){
        if(check[i]){
            prime2[count2++] = i;    
        }
        for(int j=0; j<count2; j++){
            if(i*prime2[j] > maxn) break;
            check[i*prime2[j]] = 0;
            if(i%prime2[j] == 0) break;
        } 
    }    
}
```

### 质数区间筛
```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;

const int maxn = 2e5+10;

bool isPrimeSmall[maxn];
bool isPrimeBig[maxn];

ll  getInterval(ll a, ll b){
    memset(isPrimeSmall , 1 , sizeof isPrimeSmall);
    memset(isPrimeBig , 1 , sizeof isPrimeBig);
    isPrimeSmall[0] = isPrimeSmall[1] = 0;
    for(ll i = 2; i*i<b; i++){
        if(isPrimeSmall[i]){
            for(ll j=2*i; j*j<b; j+=i){
                isPrimeSmall[j] = 0;
            }
            for(ll k = max(2LL, (a+i-1) / i) * i; k<=b; k+=i){
                isPrimeBig[k - a] = 0;
            }
        }
    }
    ll ans = 0;
    for(ll i=0; i<= b-a; i++){
        if(isPrimeBig[i])    ans ++;
    }
    
    if(a == 1)    ans--;//防止1被当成质数 
    return ans;
}

int main()
{
    ll a,b;
    int t;
    scanf("%d",&t);
    int cas = 1;
    while(t--)
    {
        scanf("%lld %lld",&a,&b);
        printf("Case %d: %lld\n",cas++, getInterval(a,b));
    }
    return 0;
}
```

### 欧拉函数筛

```c++
#define Max 1000  
int euler[Max];  
void Init(){   
     euler[1]=1;  

     for(int i=2;i<Max;i++)  
       euler[i]=i;  //初始化φ(x)=x
     for(int i=2;i<Max;i++)  
        if(euler[i]==i)  //这个欧拉值没有被更新过则需要更新，保证了进行更新时，i一定是素数
           for(int j=i;j<Max;j+=i)  
              euler[j]=euler[j]/i*(i-1);//先进行除法是为了防止中间数据的溢出   
}
```

***

## DP
### 区间DP
```c++
int a[maxn];
int sum[maxn];
int dp[maxn][maxn];
int n;

void solve(){
    rep(len , 2, n){
        rep(i, 1, n){
            int j=i+len-1;
            if(j > n) break;
            dp[i][j] = inf;
            rep(k, i, j-1){
                dp[i][j] = min(dp[i][j] , dp[i][k] + dp[k+1][j] + sum[j] - sum[i-1]);
            }
        }
    }
    
}
int main(){
    int t;
    sc(t);
    while(t--){
        sc(n);
        MS(sum,0);
        rep(i,1,n){
            sc(a[i]);
            sum[i] = sum[i-1] + a[i];
        } 
        solve();
        cout<<dp[1][n]<<endl; 
    }
    return 0;
}
```

### 数位DP
```c++
//不要62 和 4
const int maxn = 1e5+10;
ll a[30];
ll dp[30][2];


ll dfs(int pos , bool limit, bool lead, bool status){
    if(pos == -1) return 1;
    if(!limit && !lead && dp[pos][status] != -1)  return dp[pos][status];
    int up = limit ? a[pos] : 9;
    ll ans = 0;
    for(int i=0; i<=up; i++){
        if(i == 4) continue;
        if(status && i==2) continue;
        ans += dfs(pos-1 , limit && i==a[pos] , lead && i==0, i==6);
    }

    if(!limit && !lead) dp[pos][status] = ans;
    return ans;
}
ll solve(int x){
    int pos = -1;
    while(x){
        pos++;
        a[pos] = x % 10;
        x /= 10;
    }
    return dfs(pos , 1 , 1, 0);
}
ll l,r;
int main(){
    while(cin>>l>>r){
        if(l == 0 && r==0) break;
        for(int i=0; i<=20; i++){
            dp[i][0] = -1;
            dp[i][1] = -1;
        }
        cout<<solve(r) - solve(l-1)<<endl;
    }
}
```


### 子序列 
- LIS 最长上升子序列
```c++
//O(n^2)
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <cmath>
using namespace std;
const int maxn = 103, INF = 0x7f7f7f7f;
int a[maxn], f[maxn];
int n,ans = -INF;
int main()
{
    scanf("%d", &n);
    for(int i=1; i<=n; i++) 
    {
        scanf("%d", &a[i]);
        f[i] = 1;
    }
    for(int i=1; i<=n; i++)
        for(int j=1; j<i; j++)
            if(a[j] < a[i])
                f[i] = max(f[i], f[j]+1);
    for(int i=1; i<=n; i++) 
        ans = max(ans, f[i]);
    printf("%d\n", ans);
    return 0;
}

//O(n*logn)
int num[10]={3,6,3,2,4,6,7,5,4,3};  
  
const int INF=0x3f3f3f3f;  
int l=10, g[100], d[100];  
 
int main()  
{  
    fill(g, g+l, INF);  
    int max_=-1;  
    for(int i=0; i<l; i++)  
    {  
        int j = lower_bound(g, g+l, num[i]) - g;  
        d[i] = j+1;  
        if(max_<d[i])  
            max_=d[i];  
        g[j] = num[i];  
    }  
    printf("%d\n", max_);  
    return 0;  
}  

```
---
- LCS 最长公共子序列
```c++

string s1,s2;
int dp[maxn][maxn];
int path[maxn][maxn];
int len1;
int len2 ;
int LCS(){
    for(int i=1; i<=len1; i++){
        for(int j=1; j<=len2; j++){
            if(s1[i-1] == s2[j-1]){
                dp[i][j] = dp[i-1][j-1] + 1;
                path[i][j] = 1;
            } 
            else{
                //从左边来
                if(dp[i-1][j] > dp[i][j-1]){
                    dp[i][j] = dp[i-1][j] ;
                    path[i][j] = 2;
                }
                //从上面来
                else{
                    dp[i][j] = dp[i][j-1];
                    path[i][j] = 3;
                }
            }

        }
    }
    return dp[len1][len2];
}

void showPath(int p1 , int p2){
    if(p1 == 0 || p2 == 0){
        return;
    } 
    if(path[p1][p2] == 1){
        showPath(p1-1, p2-1);
        cout<<s1[p1-1];
    }
    else if(path[p1][p2] == 2) showPath(p1-1, p2);
    else if(path[p1][p2] == 3) showPath(p1, p2-1);
    
}

int main(){
    while(cin>>s1>>s2){
        len1 = s1.length();
        len2 = s2.length();
        MS(dp , 0);
        MS(path ,  0);
        //LCS();
        // showPath(len1 , len2);
        // if(dp[len1][len2])
        //     cout<<endl;
        cout<<LCS()<<endl;
    }
    return 0;
}
```

### 概率DP(逆推)
```c++
#include<iostream>
#include<queue>
#include<stack>
#include<list>
#include<vector>
#include<cstring>
#include<set>
using namespace std;
typedef long long ll;
const int maxn = 1e5+10;
int a,b,c;
double dp[105][105][105];
void show(int i, int j, int k){
    printf("dp[%d][%d][%d] = %.10f\n", i,j,k,dp[i][j][k]);
}

double p1,p2,p3;
int main(){
    while(cin>>a>>b>>c){
        memset(dp , 0 , sizeof dp);
        dp[a][b][c] = 1;
        for(int i=a; i>=0; i--){
            for(int j=b; j>=0; j--){
                for(int k=c; k>=0; k--){
                    // int total = i + j + k;
                    // total = total * (total - 1) / 2;
                    int total = i*j + i*k + j*k;
                     p1 = 1.0*i*j / total;
                     p2 = 1.0*k*j / total;
                     p3 = 1.0*i*k / total;
                    // cout<<"p1 = "<<p1<<" p2 = "<<p2<<" p3 = "<<p3<<endl;
                    if(i && j) //石头和剪刀相遇 
                        dp[i][j-1][k] += p1 * dp[i][j][k];
                    if(j && k)  //剪刀和布相遇 
                        dp[i][j][k-1] += p2 * dp[i][j][k];
                    if(i && k) //石头和布相遇
                        dp[i-1][j][k] += p3 * dp[i][j][k];
                }
            }
        }
        double x,y,z;
        x = y = z = 0;
        for(int i=1; i<=a; i++){
            x += dp[i][0][0];
        }
        for(int i=1; i<=b; i++){
            y += dp[0][i][0];
        }
        for(int i=1; i<=c; i++){
            z += dp[0][0][i];
        }
        printf("%.10f %.10f %.10f\n" , x,y,z);
    }
    return 0;
}
```

### 期望DP(向前转移或者回到自己)
  - 骰子n个面全部看到需要投多少次
    - dp[i] = (n-i)/n*dp[i+1]  + i/n*dp[i] + 1
    ```c++
    const int maxn = 1e5+10;
    double dp[maxn];//dp[i]表示已经涂了i个 还需要多少次才能到达终点
    int t,n;
    int cnt = 1;
    int main(){
        
        cin>>t;
        while(t--){
            cin>>n;
            for(int i=0; i<=n; i++) dp[i] = 0.0;
            dp[n] = 0;
            for(int i=n-1; i>=0; i--){
                double p = 1.0*i/n;
                dp[i] = dp[i+1] + 1.0/(1-p);
            }
            printf("Case %d: %.10f\n",cnt++,dp[0]);

        }
    }
    ```
- n个格子，每次随机涂一个，求涂m次后期望涂色格子数
  - dp[0] = 0
  - dp[i+1]=dp[i]+(n-dp[i])/n*1

## 组合游戏博弈

### 巴什博奕
- 只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜。
- 当 N %（M+1）= 0时，先手必败，否则，先手必胜

### 威佐夫博弈
- 有两堆物品，数量分别为M,N，两个人轮流取物品，先取完所有物品的人获胜。取物品时有两种方法，一是可以从某一堆取若干物品（至少一个，多者不限），或者是从两堆中同时取相同数量的物品。
- 我们已经知道的必败局势有（0，0）、（1，2）、（3，5）、（4，7）,我们把这种局势称之为奇异局势。可以发现，如果记（ak, bk）为第k个奇异局势（第0个必败局势是（0,0）），那么ak是之前未出现过的最小数字，bk = ak + k;
- 解决方法
  - 对于初始给定状态a b， a <= b先求出k = b - a;
  - 再验证a == k * (1+√5)/2  (右边下取整)


### 尼姆博弈
- 有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜
- 首先我们分分析一下奇异局势。（0,0,0）是第一个奇异局势，然后可以证明（0，n,  n）是奇异局势，因为只要把这个局势留给对面，对面在一堆中取几个，那么我们都在另外一堆取相同数目的物品，到最后肯定胜利。
- 如果面临的局势是（1,2,3），你可以发现这也是一个奇异局势，因为无论怎么取，对手必然可以将其变为（0，n,  n）的局势留给你。
- 如果局势（x,y,z）是奇异局势，那么x xor y xor z = 0.